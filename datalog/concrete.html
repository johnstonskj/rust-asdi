<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Concrete Syntax - Another Simplistic Datalog Implementation (in Rust)</title>
        <!-- Custom HTML head -->
<link   rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"
        integrity="sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs"
        crossorigin="anonymous">
<script defer
        src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"
        integrity="sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx"
        crossorigin="anonymous"></script>
<script defer
        src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js"
        integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR"
        crossorigin="anonymous"></script>

<script defer>
document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "\\(", right: "\\)", display: false},
            {left: "$", right: "$", display: false},
            {left: "\\[", right: "\\]", display: true}
        ]
    });
});
</script>

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../asdi.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../introduction/introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../datalog/index.html"><strong aria-hidden="true">2.</strong> Datalog</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../datalog/abstract.html"><strong aria-hidden="true">2.1.</strong> Abstract Syntax</a></li><li class="chapter-item expanded "><a href="../datalog/concrete.html" class="active"><strong aria-hidden="true">2.2.</strong> Concrete Syntax</a></li><li class="chapter-item expanded "><a href="../datalog/relational.html"><strong aria-hidden="true">2.3.</strong> Relational Algebra Mapping</a></li><li class="chapter-item expanded "><a href="../datalog/features.html"><strong aria-hidden="true">2.4.</strong> Language Features</a></li></ol></li><li class="chapter-item expanded "><a href="../model/index.html"><strong aria-hidden="true">3.</strong> Model API</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../model/programs.html"><strong aria-hidden="true">3.1.</strong> Programs</a></li><li class="chapter-item expanded "><a href="../model/relations.html"><strong aria-hidden="true">3.2.</strong> Relations</a></li><li class="chapter-item expanded "><a href="../model/queries.html"><strong aria-hidden="true">3.3.</strong> Queries</a></li><li class="chapter-item expanded "><a href="../model/views.html"><strong aria-hidden="true">3.4.</strong> Views</a></li></ol></li><li class="chapter-item expanded "><a href="../extension/index.html"><strong aria-hidden="true">4.</strong> Model Extension</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../extension/evaluator.html"><strong aria-hidden="true">4.1.</strong> Writing an Evaluator</a></li><li class="chapter-item expanded "><a href="../extension/typeset.html"><strong aria-hidden="true">4.2.</strong> Writing a Typesetter</a></li></ol></li><li class="chapter-item expanded "><a href="../reference/abstract_graph.html"><strong aria-hidden="true">5.</strong> Appendix: Abstract Graphical View</a></li><li class="chapter-item expanded "><a href="../reference/logic.html"><strong aria-hidden="true">6.</strong> Appendix: First-Order Logic &amp; Horn Clauses</a></li><li class="chapter-item expanded "><a href="../reference/datalog_ebnf.html"><strong aria-hidden="true">7.</strong> Appendix: Datalog EBNF</a></li><li class="chapter-item expanded "><a href="../reference/relational_ebnf.html"><strong aria-hidden="true">8.</strong> Appendix: Relational Algebra EBNF</a></li><li class="chapter-item expanded "><a href="../reference/references.html"><strong aria-hidden="true">9.</strong> Appendix: References</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Another Simplistic Datalog Implementation (in Rust)</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/johnstonskj/rust-asdi" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="concrete-syntax"><a class="header" href="#concrete-syntax">Concrete Syntax</a></h1>
<p>The definitions below uses both Extended Backus-Naur Form (EBNF) and syntax diagrams to focus on the
concrete syntax as expressed in the text representation. The EBNF definition is somewhat simplified
from the grammar used in the ASDI parser although any deviations do not significantly affect the
meaning of the language.</p>
<p>For the original description of the EBNF notation as it is used here, please refer to “<a href="http://www.w3.org/TR/2010/REC-xquery-20101214/#EBNFNotation">A.1.1
Notation</a>” in the <a href="http://www.w3.org/TR/2010/REC-xquery-20101214/">XQuery
recommendation</a>. The diagrams included below were
generated by the <a href="https://www.bottlecaps.de/rr/ui">bottlecaps</a> online tool from the definition in the
<a href="../reference/datalog_ebnf.html">appendix</a>.</p>
<h2 id="programs"><a class="header" href="#programs">Programs</a></h2>
<p>A program consists of a set of facts that comprise the extensional database, a list of rules that
comprise the intensional database, and possibly a set of queries to interrogate the result of any
reasoning performed over the program.</p>
<p><img src="images/program.png" alt="program" /></p>
<pre><code class="language-ebnf">program
        ::= pragma* ( fact | rule | query )* ;
</code></pre>
<p>A program consists of a single file containing facts, rules, and queries as well as any additional
files referenced via <em>pragmas</em>.</p>
<h2 id="facts"><a class="header" href="#facts">Facts</a></h2>
<p>Facts <strong>must</strong> be expressed in the form of ground atoms and so they have a specific rule rather
than a constrained form of the <code>atom</code> rule.</p>
<p><img src="images/fact.png" alt="fact" /></p>
<pre><code class="language-ebnf">fact
        ::= predicate ( &quot;(&quot; constant ( &quot;,&quot; constant )* &quot;)&quot; )? &quot;.&quot; ;
</code></pre>
<p>A predicate is the identifier shared by a fact and relation.</p>
<p><img src="images/predicate.png" alt="predicate" /></p>
<pre><code class="language-ebnf">predicate
        ::= LC_ALPHA ( ALPHA | DIGIT | &quot;_&quot; )* ;
</code></pre>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<p>The following demonstrates a simple fact denoting that the constant <code>brooke</code> representing some
individual is the parent of some individual represented by the constant <code>&quot;Xerces&quot;</code>.</p>
<pre><code class="language-datalog">parent(&quot;Xerces&quot;, brooke).
</code></pre>
<h2 id="constant-values"><a class="header" href="#constant-values">Constant Values</a></h2>
<p>Constants are supported in three types, String, Integer, and Boolean. Whereas some definitions of
Datalog introduce an additional Identifier type, ASDI treats these as <em>short strings</em> that can
safely be expressed without quotes; therefore, the values <code>xerces</code> and <code>&quot;xerces&quot;</code> are equivalent.</p>
<p><img src="images/constant.png" alt="constant" /></p>
<pre><code class="language-ebnf">constant
        ::= string | integer | boolean ;
</code></pre>
<p>Strings are described in both the identifier and quoted form in the <code>string</code> rule.</p>
<p><img src="images/string.png" alt="string" /></p>
<pre><code class="language-ebnf">string
        ::= predicate ( &quot;:&quot; ALPHA ( ALPHA | DIGIT | &quot;_&quot; * )? )
            | DQUOTE [^\u{22}]* DQUOTE ;
</code></pre>
<p>Integers bounds are currently unspecified, just strings of decimal digits.</p>
<p><img src="images/integer.png" alt="integer" /></p>
<pre><code class="language-ebnf">integer
        ::= ( &quot;+&quot; | &quot;-&quot; )? DIGIT+ ;
</code></pre>
<p>Boolean values may also be represented using <code>⊤</code> (down tack <code>\u{22a4}</code>) for true, and <code>⊥</code> (up tack
<code>\u{22a5}</code>) for false where this may improve readability.</p>
<p><img src="images/boolean.png" alt="boolean" /></p>
<pre><code class="language-ebnf">boolean
        ::= ( &quot;true&quot; | &quot;⊤&quot; ) | ( &quot;false&quot; | &quot;⊥&quot; ) ;
</code></pre>
<h3 id="rules"><a class="header" href="#rules">Rules</a></h3>
<p>As facts are syntactically distinct from rules in the text representation there is no need for empty
bodies – all rules <strong>must</strong> have at least one literal. Material implication may be written using
the Unicode character <code>⟵</code> (long leftwards arrow<code>\u{27f5}</code>).</p>
<p><img src="images/rule.png" alt="rule" /></p>
<pre><code class="language-ebnf">rule
        ::= ( head | &quot;⊥&quot; )? ( &quot;:-&quot; | &quot;&lt;-&quot; | &quot;⟵&quot; ) body &quot;.&quot; ;
</code></pre>
<p>The head of a rule is a disjunction of atoms, or in the case of a constraint the head may is
optional or replaced by the value <code>&quot;⊥&quot;</code>.</p>
<p><img src="images/head.png" alt="head" /></p>
<pre><code class="language-ebnf">head
        ::= ( atom ( ( &quot;;&quot; | &quot;|&quot; | &quot;OR&quot; | &quot;∨&quot; ) atom )* ) ;
</code></pre>
<p>The body of a rule is comprised of one, or more, literals.</p>
<p><img src="images/body.png" alt="body" /></p>
<pre><code class="language-ebnf">body
        ::= literal ( ( &quot;,&quot; | &quot;&amp;&quot; | &quot;AND&quot; | &quot;∧&quot; ) literal )* ;
</code></pre>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<p>The following sets of rules are equivalent.</p>
<pre><code class="language-datalog">ancestor(X, Y) :- parent(X, Y).
ancestor(X, Y) &lt;- parent(X, Y).
ancestor(X, Y) ⟵ parent(X, Y).

movie_star(X) :- star(X)  ,  movie_cast_member(X, _, _).
movie_star(X) :- star(X)  &amp;  movie_cast_member(X, _, _).
movie_star(X) :- star(X) AND movie_cast_member(X, _, _).
movie_star(X) :- star(X)  ∧  movie_cast_member(X, _, _).
</code></pre>
<p>As described in the abstract syntax it is an error to use an extensional relation in the head of
a rule. The following will generate an error:</p>
<pre><code class="language-datalog">parent(&quot;Xerces&quot;, brooke).

parent(X,Y) :- father(X,Y).
</code></pre>
<p>The language feature <code>disjunction</code> corresponds to the language $\small\text{Datalog}^{\lor}$ and
allows multiple atoms to appear in the rule’s head with the semantics that these are choices. This
syntax will not be accepted unless the feature is enabled.</p>
<p>For example, the following describes the rule that <em>if X is a parent then X is <strong>either</strong> a
father <strong>or</strong> mother</em>.</p>
<pre><code class="language-datalog">.feature(disjunction).

father(X) ;  mother(X) :- parent(X).
father(X) |  mother(X) :- parent(X).
father(X) OR mother(X) :- parent(X).
father(X) ⋁  mother(X) :- parent(X).
</code></pre>
<p>As the use of disjunction in this position in the head is <em>inclusive</em> it is considered that any rule as above can be transformed
into the following standard form. Clearly, in this case this is not the expected semantics which would require
an exclusive disjunction, the language $\small\text{Datalog}^{\oplus}$. Because the semantics may
cause such confusion ASDI does not do this transformation by default.</p>
<pre><code class="language-datalog">father(X) :- parent(X).
mother(X) :- parent(X).
</code></pre>
<p>The language feature <code>constraints</code> corresponds to the language $\small\text{Datalog}^{\Leftarrow}$ and
allows the specification of rules with no head. In this case the material implication symbol is
<strong>required</strong>, the falsum value is optional for readability, therefore the following rules are
equivalent.</p>
<pre><code class="language-datalog">.feature(constraints).

:- alive(X) AND dead(X).
⊥ ⟵ alive(X) ∧ dead(X).
</code></pre>
<h3 id="safety"><a class="header" href="#safety">Safety</a></h3>
<p>ASDI will disallow the addition of rules that are unsafe according to the abstract syntax. The
following are examples of unsafe rules:</p>
<ul>
<li><code>a(X) :- b(Y).</code> — because <code>X</code> appears as a distinguished variable but does not appear in a
positive relational literal, error
<a href="error/enum.Error.html#variant.NegativeVariablesNotAlsoPositive"><code>HeadVariablesMissingInBody</code></a>.</li>
<li><code>a(X) :- b(Y), NOT b(X).</code> — because <code>X</code> appears in a negated literal but does not appear in a
positive relational literal, error
<a href="error/enum.Error.html#variant.NegativeVariablesNotAlsoPositive"><code>NegativeVariablesNotAlsoPositive</code></a>.</li>
<li><code>a(X) :- b(Y), X &lt; Y.</code> — Because <code>X</code> appears in an arithmetic literal but does not appear in a
positive relational literal, error
<a href="error/enum.Error.html#variant.ArithmeticVariablesNotAlsoPositive"><code>ArithmeticVariablesNotAlsoPositive</code></a>.</li>
</ul>
<h2 id="atoms"><a class="header" href="#atoms">Atoms</a></h2>
<p>The text representation of an atom is a relatively simple translation from the abstract syntax
above.</p>
<p><img src="images/atom.png" alt="atom" /></p>
<pre><code class="language-ebnf">atom
        ::= predicate &quot;(&quot; term ( &quot;,&quot; term )* &quot;)&quot; ;
</code></pre>
<p><img src="images/term.png" alt="term" /></p>
<pre><code class="language-ebnf">term
        ::= variable | constant ;
</code></pre>
<p>Note that we explicitly separate variables into named and anonymous forms here.</p>
<p><img src="images/variable.png" alt="variable" /></p>
<pre><code class="language-ebnf">variable
        ::= named-variable | anon-variable ;
</code></pre>
<p><img src="images/named-variable.png" alt="named-variable" /></p>
<pre><code class="language-ebnf">named-variable
        ::= UC_ALPHA ( ALPHA | DIGIT | &quot;_&quot; )* ;
anon-variable
        ::= &quot;_&quot; ;
</code></pre>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<p>The following are all valid body atoms.</p>
<pre><code class="language-datalog">dead(julius_caesar).
emperor(julius_caesar, rome).
emperor(X, Y).
emperor(X, rome).
</code></pre>
<h2 id="literals"><a class="header" href="#literals">Literals</a></h2>
<p>Any valid atom is also a valid <em>positive relational</em> literal. The syntax below also allows for <em>negative</em>
literals as well as arithmetic expressions as literals. Conjunction may be written with the Unicode
character <code>∧</code> (logical and <code>\u{2227}</code>).</p>
<p><img src="images/literal.png" alt="literal" /></p>
<pre><code class="language-ebnf">literal
        ::= ( &quot;!&quot; | &quot;NOT&quot; | &quot;￢&quot; )? ( atom | comparison ) ;
</code></pre>
<h3 id="examples-1"><a class="header" href="#examples-1">Examples</a></h3>
<p>The following rules are all equivalent.</p>
<pre><code class="language-datalog">ancestor(X, Y) ⟵ parent(X, Z)  ,  ancestor(Z, Y).
ancestor(X, Y) ⟵ parent(X, Z)  &amp;  ancestor(Z, Y).
ancestor(X, Y) ⟵ parent(X, Z)  ∧  ancestor(Z, Y).
ancestor(X, Y) ⟵ parent(X, Z) AND ancestor(Z, Y).
</code></pre>
<p>The language feature <code>negation</code> corresponds to the language $\small\text{Datalog}^{\lnot}$ and
allows the specification of negated literals. Negation may also be written using the Unicode
character <code>￢</code> (full-width not sign <code>\u{ffe2}</code>). The following rules are equivalent.</p>
<pre><code class="language-datalog">.feature(negation).

alive(X) :- person(X), NOT dead(X).
alive(X) ⟵ person(X) ∧ ￢dead(X).
</code></pre>
<p>The following will fail as the negated rule is not considered safe ([Error::NegativeVariablesNotAlsoPositive]).</p>
<pre><code class="language-datalog">.feature(negation).

alive(X) :- NOT dead(X).
alive(X) ⟵ ￢dead(X).
</code></pre>
<h2 id="arithmetic-literals"><a class="header" href="#arithmetic-literals">Arithmetic Literals</a></h2>
<p>The language feature <code>comparisons</code> corresponds to the language $\small\text{Datalog}^{\theta}$ and
allows the use of arithmetic literals. Comparisons take place between two literals and are
currently limited to a set of common operators. Note the addition of a string match operator, this
is similar to the Perl <code>=~</code> and requires a string value/variable on the left and a string value or
variable on the right that compiles to a valid Rust regular expression. Finally, the rule <code>named-term</code>
disallows the use of anonymous variables in arithmetic literals.</p>
<p><img src="images/comparison.png" alt="comparison" /></p>
<pre><code class="language-ebnf">comparison
        ::= ( named-variable | constant ) operator ( named-variable | constant ) ;
</code></pre>
<p><img src="images/operator.png" alt="operator" /></p>
<pre><code class="language-ebnf">operator
        ::= &quot;=&quot;
            | (&quot;!=&quot; | &quot;/=&quot; | &quot;≠&quot;)
            | &quot;&lt;&quot;
            | (&quot;&lt;=&quot; | &quot;≤&quot;)
            | &quot;&gt;&quot;
            | (&quot;&gt;=&quot; | &quot;≥&quot;)
            | (&quot;*=&quot; | &quot;≛&quot; | &quot;MATCHES&quot;) ;
</code></pre>
<p>The Unicode characters <code>≠</code> (not equal to <code>\u{2260}</code>), <code>≤</code> (less-than or equal to <code>\u{2264}</code>),
<code>≥</code> (greater-than or equal to <code>\u{2265}</code>, and star equals <code>\u{e2899b}</code>) may be substituted for the
common arithmetic and string operators.</p>
<p>All arithmetic operations <strong>must</strong> be between terms of the some type, such that the property
<em>compatible</em> introduce above is defined as:</p>
<p>$$\tag{xvi}\small compatible(\tau_{lhs}, \tau_{rhs}, \theta) \leftarrow \tau_{lhs} = \tau_{rhs}$$</p>
<p>Additionally, some operators are not present for all types, as shown in the table below.</p>
<table><thead><tr><th>Type</th><th><code>=</code>, <code>≠</code></th><th><code>&lt;</code>, <code>≤</code>, <code>&gt;</code>, <code>≥</code></th><th><code>≛</code></th></tr></thead><tbody>
<tr><td>String</td><td>Yes</td><td>Yes - lexical</td><td>Yes</td></tr>
<tr><td>Integer</td><td>Yes</td><td>Yes</td><td>No</td></tr>
<tr><td>Boolean</td><td>Yes</td><td>No</td><td>No</td></tr>
</tbody></table>
<h3 id="example-2"><a class="header" href="#example-2">Example</a></h3>
<p>The following is an example using arithmetic literals and the <em>car</em> relation.</p>
<pre><code class="language-datalog">.feature(comparisons).
.assert car(make: string, model: string, age: integer).

antique(X, Y) :- car(X, Y, _) AND X *= &quot;[dD]uesenberg&quot;.
antique(X, Y) :- car(X, Y, _) AND Y = &quot;model t&quot;.
antique(X, Y) :- car(X, Y, Z) AND Z &gt; 50.
</code></pre>
<h2 id="queries"><a class="header" href="#queries">Queries</a></h2>
<p>A query is simply an atom, but one identified to the system as a goal with either the prefix <code>?-</code>
or the suffix <code>?</code>.</p>
<p><img src="images/query.png" alt="query" /></p>
<pre><code class="language-ebnf">query
        ::= ( &quot;?-&quot; atom &quot;.&quot; ) | ( atom &quot;?&quot; ) ;
</code></pre>
<h3 id="examples-2"><a class="header" href="#examples-2">Examples</a></h3>
<p>The following queries are equivalent and will return the value of the variable <code>X</code> for any facts in
the <em>ancestor</em> relationship where the first attribute is the string value <code>&quot;xerces&quot;</code>.</p>
<pre><code class="language-datalog">?- ancestor(xerces, X).
ancestor(xerces, X)?
</code></pre>
<p>When the value <code>_</code> is used in a query it denotes an attribute of the relation that has no meaning
in either the query or the response. For example, in the following query we ask for all values of
the <em>model</em> attribute in the <em>car</em> relation where the <em>make</em> is “ford”, and ignore the age entirely.</p>
<pre><code class="language-datalog">.assert car(make: string, model: string, age: integer).

car(&quot;ford&quot;, X, _)?
</code></pre>
<p>The results of this query would not include the age column:</p>
<pre><code class="language-text">+------------+
| model      |
+============+
| edge       |
+------------+
| escort     |
+------------+
| fiesta     |
+------------+
| focus      |
+------------+
| fusion     |
+------------+
| mustang    |
+------------+
     ...
</code></pre>
<h2 id="pragmas"><a class="header" href="#pragmas">Pragmas</a></h2>
<p>Pragmas are declarative statements meant for the parser and runtime tooling, they do not affect
the meaning of the program itself.</p>
<p><img src="images/pragma.png" alt="pragma" /></p>
<pre><code class="language-ebnf">pragma
        ::= &quot;.&quot; ( feature | assert | infer | input | output ) ;
</code></pre>
<p>The <code>feature</code> pragma determines which Datalog language is in use. Use of syntax not supported by the
selected language feature will result in errors.</p>
<p><img src="images/feature.png" alt="feature" /></p>
<pre><code class="language-ebnf">feature
        ::= &quot;feature&quot; &quot;(&quot; feature-id ( &quot;,&quot; feature-id )* &quot;)&quot; &quot;.&quot; ;
</code></pre>
<p><img src="images/feature-id.png" alt="feature-id" /></p>
<pre><code class="language-ebnf">feature-id
        ::= &quot;comparisons&quot; | &quot;constraints&quot; | &quot;disjunction&quot; | &quot;negation&quot; ;
</code></pre>
<h3 id="example-3"><a class="header" href="#example-3">Example</a></h3>
<pre><code class="language-datalog">.feature(negation).
.feature(comparisons, disjunction).
</code></pre>
<p>The <code>assert</code> pragma describes a new relation in the extensional database. The parser can determine
the schema for facts from their types in the database. The use of this pragma is therefore optional,
but recommended.</p>
<p><img src="images/assert.png" alt="assert" /></p>
<pre><code class="language-ebnf">assert
        ::= &quot;assert&quot; predicate &quot;(&quot; attribute-decl ( &quot;,&quot; attribute-decl )* &quot;)&quot; &quot;.&quot; ;
</code></pre>
<p><img src="images/attribute-decl.png" alt="attribute-decl" /></p>
<pre><code class="language-ebnf">attribute-decl
        ::= ( predicate &quot;:&quot; )? ( &quot;boolean&quot; | &quot;integer&quot; | &quot;string&quot; ) ;
</code></pre>
<h3 id="example-4"><a class="header" href="#example-4">Example</a></h3>
<pre><code class="language-datalog">.assert human(name: string).
</code></pre>
<p>The <code>infer</code> pragma describes a new relation in the intensional database. Typically the parser
can determine the schema for relational literals from their context, The use of this pragma
is therefore optional, but recommended. The alternate form is more explicit in that it defines
an intensional relation in terms of a previously defined extensional relation.</p>
<p><img src="images/infer.png" alt="infer" /></p>
<pre><code class="language-ebnf">infer
        ::= &quot;infer&quot;
            ( predicate &quot;(&quot; attribute-decl ( &quot;,&quot; attribute-decl )* &quot;)&quot; )
            | &quot;from&quot; predicate &quot;.&quot; ;
</code></pre>
<h3 id="example-5"><a class="header" href="#example-5">Example</a></h3>
<pre><code class="language-datalog">.infer mortal(name: string).
</code></pre>
<p>Alternatively the short-cut form is often more convenient.</p>
<pre><code class="language-datalog">.assert human(name: string).
.infer mortal from human.
</code></pre>
<p>The <code>input</code> pragma instructs the parser to load facts for the named extensional relation from an
external file. This pragma <strong>requires</strong> that the relation be previously defined via the <code>assert</code>
pragma.</p>
<p><img src="images/input.png" alt="input" /></p>
<pre><code class="language-ebnf">input
        ::= &quot;input&quot; io-details &quot;.&quot;
</code></pre>
<p><img src="images/io-details.png" alt="io-details" /></p>
<pre><code class="language-ebnf">io-details
        ::= &quot;(&quot; predicate &quot;,&quot; quoted-string ( &quot;,&quot; quoted-string )? &quot;)&quot; ;
</code></pre>
<h3 id="example-6"><a class="header" href="#example-6">Example</a></h3>
<pre><code class="language-datalog">.assert human(name: string).
.input(human, &quot;data/humans.csv&quot;, &quot;csv&quot;).
</code></pre>
<p>The <code>output</code> pragma instructs the parser to write facts from the named intensional relation to an
external file. This pragma <strong>requires</strong> that the relation be previously defined via the <code>infer</code>
pragma.</p>
<p><img src="images/output.png" alt="output" /></p>
<pre><code class="language-ebnf">output
        ::= &quot;output&quot; io-details &quot;.&quot; ;
</code></pre>
<h3 id="example-7"><a class="header" href="#example-7">Example</a></h3>
<pre><code class="language-datalog">.infer mortal(name: string).
.output(mortal, &quot;data/mortals.txt&quot;).
</code></pre>
<h2 id="comments"><a class="header" href="#comments">Comments</a></h2>
<p>Comments in Datalog are either 1) the <code>%</code> character and continue to the end of the line, or
2) C-style with <code>/*</code> to start and <code>*/</code> to end. These correspond to the same rules as Prolog.</p>
<p><img src="images/comment.png" alt="comment" /></p>
<pre><code class="language-ebnf">comment
        ::= &quot;%&quot; [^\r\n]* EOL
            | &quot;/&quot; &quot;*&quot; ( [^\*] | &quot;*&quot;+ [^\*\/] )* &quot;*&quot;+ &quot;/&quot; ;
</code></pre>
<h3 id="example-8"><a class="header" href="#example-8">Example</a></h3>
<pre><code class="language-datalog">% Here's a comment
?- ancestor(xerces, X). % and another
?- ancestor(brooke /* and one inline */, X). % and another
</code></pre>
<h2 id="terminal-lexical-symbols"><a class="header" href="#terminal-lexical-symbols">Terminal (Lexical) Symbols</a></h2>
<p>The following are lexical rules that can be assumed by the rules above.</p>
<pre><code class="language-ebnf">EOL
        ::= &quot;\n&quot; | &quot;\r\n&quot; | &quot;\r&quot; ;
WHITESPACE
        ::= &quot; &quot; | &quot;\t&quot; | EOL ;
DQUOTE
        ::= '&quot;' ;
LC_ALPHA
        ::= ? corresponds to the Unicode category 'Ll' ? ;
UC_ALPHA
        ::= ? corresponds to the Unicode category 'Lu' ? ;
ALPHA
        ::= LC_ALPHA | UC_ALPHA ;
DIGIT
        ::= ? corresponds to the Unicode category 'Nd' (decimal number) ? ;
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../datalog/abstract.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../datalog/relational.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../datalog/abstract.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../datalog/relational.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../datalog.js"></script>
        <script type="text/javascript" src="../dot.js"></script>
        <script type="text/javascript" src="../asdi.js"></script>
    </body>
</html>
