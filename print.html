<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Another Simplistic Datalog Implementation (in Rust)</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
<link   rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"
        integrity="sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs"
        crossorigin="anonymous">
<script defer
        src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"
        integrity="sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx"
        crossorigin="anonymous"></script>
<script defer
        src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js"
        integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR"
        crossorigin="anonymous"></script>

<script defer>
document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "\\(", right: "\\)", display: false},
            {left: "$", right: "$", display: false},
            {left: "\\[", right: "\\]", display: true}
        ]
    });
});
</script>

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="asdi.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction/introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="datalog/index.html"><strong aria-hidden="true">2.</strong> Datalog</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="datalog/abstract.html"><strong aria-hidden="true">2.1.</strong> Abstract Syntax</a></li><li class="chapter-item expanded "><a href="datalog/concrete.html"><strong aria-hidden="true">2.2.</strong> Concrete Syntax</a></li><li class="chapter-item expanded "><a href="datalog/features.html"><strong aria-hidden="true">2.3.</strong> Language Features</a></li></ol></li><li class="chapter-item expanded "><a href="model/index.html"><strong aria-hidden="true">3.</strong> Model API</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="model/programs.html"><strong aria-hidden="true">3.1.</strong> Programs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="model/program_features.html"><strong aria-hidden="true">3.1.1.</strong> Features</a></li><li class="chapter-item expanded "><a href="model/program_parser.html"><strong aria-hidden="true">3.1.2.</strong> Parser</a></li><li class="chapter-item expanded "><a href="model/program_visitor.html"><strong aria-hidden="true">3.1.3.</strong> Visitor</a></li></ol></li><li class="chapter-item expanded "><a href="model/relations.html"><strong aria-hidden="true">3.2.</strong> Relations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="model/relation_io.html"><strong aria-hidden="true">3.2.1.</strong> Input/Output</a></li></ol></li><li class="chapter-item expanded "><a href="model/rules.html"><strong aria-hidden="true">3.3.</strong> Rules</a></li><li class="chapter-item expanded "><a href="model/eval.html"><strong aria-hidden="true">3.4.</strong> Evaluation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="model/eval_strata.html"><strong aria-hidden="true">3.4.1.</strong> Stratification</a></li></ol></li><li class="chapter-item expanded "><a href="model/queries.html"><strong aria-hidden="true">3.5.</strong> Queries & Views</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="model/query_relational.html"><strong aria-hidden="true">3.5.1.</strong> Relational Algebra</a></li></ol></li><li class="chapter-item expanded "><a href="model/errors.html"><strong aria-hidden="true">3.6.</strong> Error Handling</a></li></ol></li><li class="chapter-item expanded "><a href="extension/index.html"><strong aria-hidden="true">4.</strong> Model Extension</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="extension/i_o.html"><strong aria-hidden="true">4.1.</strong> RelationSet I/O</a></li><li class="chapter-item expanded "><a href="extension/evaluator.html"><strong aria-hidden="true">4.2.</strong> Writing an Evaluator</a></li><li class="chapter-item expanded "><a href="extension/formatting.html"><strong aria-hidden="true">4.3.</strong> Writing a Formatter</a></li><li class="chapter-item expanded "><a href="extension/contributing.html"><strong aria-hidden="true">4.4.</strong> Contributing</a></li></ol></li><li class="chapter-item expanded "><a href="reference/abstract_graph.html"><strong aria-hidden="true">5.</strong> Appendix: Abstract Graphical View</a></li><li class="chapter-item expanded "><a href="reference/datalog_ebnf.html"><strong aria-hidden="true">6.</strong> Appendix: Datalog EBNF</a></li><li class="chapter-item expanded "><a href="reference/relational.html"><strong aria-hidden="true">7.</strong> Appendix: Relational Algebra Mapping</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/relational_ebnf.html"><strong aria-hidden="true">7.1.</strong> Relational Algebra EBNF</a></li></ol></li><li class="chapter-item expanded "><a href="reference/logic.html"><strong aria-hidden="true">8.</strong> Appendix: Horn Clause Mapping</a></li><li class="chapter-item expanded "><a href="reference/references.html"><strong aria-hidden="true">9.</strong> Appendix: References</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Another Simplistic Datalog Implementation (in Rust)</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/johnstonskj/rust-asdi" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Another Simplistic <a href="https://en.wikipedia.org/wiki/Datalog">Datalog</a> Implementation (ASDI), in Rust.</p>
<p>Datalog is a logic programming language and a subset of the earlier <a href="https://en.wikipedia.org/wiki/Prolog">Prolog</a><sup class="footnote-reference"><a href="#1">1</a></sup>.
The language is interesting as it can be used as a data query language akin to <a href="https://en.wikipedia.org/wiki/SQL">SQL</a>
with some important additional capabilities such as recursive queries. It is also expressive enough to allow for it’s
use as an entailment mechanism for ontology languages such as the 
<a href="https://en.wikipedia.org/wiki/https://en.wikipedia.org/wiki/Web_Ontology_Language">Web Ontology Language (OWL)</a> and 
the Semantic Web.</p>
<p>This package provides an in-memory model to represent <a href="https://en.wikipedia.org/wiki/Datalog">Datalog</a> programs, a 
parser for a textual representation, relation input/output implementations and some implementations of common inference
techniques.</p>
<p><strong>Chapter 1</strong>, provides a brief simple description of Datalog by example. </p>
<p><strong>Chapter 2</strong> will provide a more detailed overview of Datalog itself from both an abstract point of view, and a tour of the 
concrete syntax used as the textual representation.</p>
<p><strong>Chapter 3</strong> will provide a guide to the crate API in a more scenario-based fashion and relies on the 
<a href="https://docs.rs/asdi/latest/asdi/">rust doc</a> to provide the definitive reference.</p>
<p><strong>Chapter 4</strong> will cover the major extension points in the crate and identify how to contribute new implementations for
specific extension traits.</p>
<h2 id="brief-datalog-example"><a class="header" href="#brief-datalog-example">Brief Datalog Example</a></h2>
<p>We will consider the following syllogism from <span class="bibref inline"><a href="introduction/../reference/references.html#Mill1851">Mill1851</a>, vol. 1, chap. 2</span>:</p>
<blockquote>
<p>All men are mortal.</p>
<p>Socrates is a man.</p>
<p>Therefore, Socrates is mortal.</p>
</blockquote>
<p>This can be represented in the following Datalog textual program.</p>
<pre><code class="language-datalog">human(&quot;Socrates&quot;).

mortal(X) &lt;- human(X).

?- mortal(&quot;Socrates&quot;).
</code></pre>
<p>The execution of this program will start with the goal query “<em>is Socrates mortal?</em>” and in
doing so will evaluate the necessary rule and derive the relation <em>mortal</em>. The result is a
boolean value denoting whether the goal is satisfied.</p>
<pre><code class="language-text">+------------+
| _: boolean |
+============+
| true       |
+------------+
</code></pre>
<p>However, if we were to change the final query to replace the constant with a variable, as follows.</p>
<pre><code class="language-datalog">?- mortal(X).
</code></pre>
<p>The program will select all matching (in this case all) facts from the <em>mortal</em> relation.</p>
<pre><code class="language-text">+------------+
| X: string  |
+============+
| &quot;Socrates&quot; |
+------------+
</code></pre>
<p>The following is the same example constructed via the ASDI library.</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use asdi::{NameReferenceSet, Program};
use asdi::edb::{Attribute, Predicate};
use asdi::idb::{Atom, Term, Variable};
use std::str::FromStr;

let mut syllogism = Program::default();

let predicates = syllogism.predicates();
let p_human = predicates.fetch(&quot;human&quot;).unwrap();
let p_mortal = predicates.fetch(&quot;mortal&quot;).unwrap();

let human = syllogism
    .add_new_extensional_relation(p_human.clone(), vec![Attribute::string()])
    .unwrap();
human.add_as_fact([&quot;Socrates&quot;.into()]).unwrap();

let variables = syllogism.variables();
let var_x: Term = variables.fetch(&quot;X&quot;).unwrap().into();

syllogism
    .add_new_pure_rule(
        p_mortal.clone(),
        [var_x.clone()],
        [Atom::new(p_human, [var_x]).into()],
    )
    .unwrap();

syllogism
    .add_new_query(p_mortal, [&quot;Socrates&quot;.into()])
    .unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>The textual form of Datalog also has a set of pragmas, or directives, which allow us to specify details of the relations
in our program. For example, in the text below we use the <code>assert</code> pragma to identify an EDB relation named “human” with
a single column of type <code>string</code>. We then go on to use the <code>infer</code> pragma to identify an IDB relation named “mortal”,
and we declare that it’s schema is the same as the EDB relation “human”.</p>
<pre><code class="language-datalog">.assert human(string).
.infer mortal from human.

human(&quot;Socrates&quot;).

mortal(X) &lt;- human(X).

?- mortal(&quot;Socrates&quot;).
</code></pre>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<pre><code class="language-text">MIT License

Copyright (c) 2021 Simon Johnston

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</code></pre>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Chapter 1 of <span class="bibref inline"><a href="introduction/../reference/references.html#CeGoTa90">CeGoTa90</a></span> provides a good overview of the drawbacks of Prolog and the advantages of Datalog for certain tasks.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="datalog"><a class="header" href="#datalog">Datalog</a></h1>
<p>Datalog is a logic programming language, but is also an expressive query language for deductive databases. As such it 
can be studied, and described, either as a programming language, as a language for expressing mathematical logic, or
as a query language. </p>
<p>When considered from a mathematical point of view it is common to start from a basis in
<a href="https://en.wikipedia.org/wiki/First-order_logic">predicate logic</a> or <a href="https://en.wikipedia.org/wiki/Horn_clause">Horn clauses</a>
and demonstrate how these relate to the rules in a Datalog program. The following section takes a more direct approach leaving
the relationship with other logic forms for a brief <a href="datalog/../reference/logic.html">appendix</a>.</p>
<p>When considered from a database or query point of view it is common to start from a basis in
<a href="https://en.wikipedia.org/wiki/Relational_algebra">relational algebra</a> and demonstrate the expressive equivalence
between it and Datalog. In considering Datalog as a query language it is noted that every expression in the 
<em>basic relational algebra</em> can be expressed as a Datalog query. A mapping from relational algebra to
Datalog is also included as an <a href="datalog/../reference/relational.html">appendix</a>.</p>
<h2 id="datalog-languages"><a class="header" href="#datalog-languages">Datalog Languages</a></h2>
<p>When we talk specifically about the Datalog language it is common to represent it in a roman serif face as 
$\small\text{Datalog}$. This allows the distinction of talking in general about Datalog in the abstract vs. the actual
semantics of the language $\small\text{Datalog}$.</p>
<p>This core $\small\text{Datalog}$ language has many documented extensions that provide additional flexibility, conciseness, or
expressiveness. These <em>languages</em>, <em>sub-languages</em>, <em>extensions</em>, or <em>dialects</em> are usually labeled by adding a superscript
symbol that identifies the specific extension. For example, $\small\text{Datalog}^{\lnot}$ is
the language extended with negation of literals, $\small\text{Datalog}^{\Gamma}$ is the language
extended with type checking on attributes, and $\small\text{Datalog}^{\lnot,\theta}$ is the language
extended with negation of literals <em>and</em> arithmetic literals. The order of superscript symbols is
irrelevant.</p>
<p>When referring to the specifics of the language we will use the common format $\small\text{Datalog}$ with
superscripts as necessary to identify specific language extensions being used.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="abstract-syntax"><a class="header" href="#abstract-syntax">Abstract Syntax</a></h1>
<p>This section describes the structure of $\small\text{Datalog}$ languages without reference to any concrete syntax
or serialized representation. The most common concrete syntax is derived from Prolog and will be described in detail in 
the <a href="datalog/concrete.html">following section</a>. In this section, text in <strong>bold</strong> indicates a key concept in the language while
text in <em>italics</em> indicates a forward reference to such a concept.</p>
<h2 id="programs"><a class="header" href="#programs">Programs</a></h2>
<p>A Datalog <strong>Program</strong> $\small P$ is a tuple comprising the <strong>Extensional</strong> database, EDB, or  $\small D_{E}$, the
<strong>Intensional</strong> database, IDB, or  $\small D_{I}$, and a set of queries $\small Q$.</p>
<p>$$\tag{0}\small P=( D_E, D_I, Q )$$</p>
<p>The extensional database in turn is a set of <em>relations</em> each of which is a set of <em>facts</em> (<em>ground atoms</em>). The intensional database is a set of <em>rules</em> that derive additional facts into intensional <em>relations</em> via entailment. </p>
<p>A program has the following properties.</p>
<ul>
<li>$\small program(x)$ a boolean predicate which returns <code>true</code> <strong>IFF</strong> $\small x$ is a program.</li>
<li>$\small extensional(P) \equiv D_E$ returns the set of relations comprising the extensional database.</li>
<li>$\small intensional(P) \equiv \lbrace r | r \in D_I \land relation(r) \rbrace$ returns the set of relations comprising the intensional database, <strong>IFF</strong> entailment has occurred. </li>
<li>$\small rules(P) \equiv \lbrace r | r \in D_I \land rule(r) \rbrace$ returns the set of rules associated with the intensional database.</li>
<li>$\small positive(r)$ a boolean predicate which returns true <strong>IFF</strong> all intensional rules are <em>positive</em>:
$$\tag{v}\small positive(p) \coloneqq (\forall{r}\in rules(p); positive(r))$$</li>
</ul>
<h2 id="rules"><a class="header" href="#rules">Rules</a></h2>
<p>Rules $\small R$ are built from a language $\small \mathcal{L}=( \mathcal{C},\mathcal{P},\mathcal{V})$
that contains the</p>
<ul>
<li>$\small \mathcal{C}$ — the finite sets of symbols for all constant values; e.g. <code>hello</code>, <code>&quot;hi&quot;</code>
<code>123</code>,</li>
<li>$\small \mathcal{P}$ — the finite set of alphanumeric character strings that begin with a
lowercase character; e.g. <code>human</code>, <code>size</code>, <code>a</code>,</li>
<li>$\small \mathcal{V}$ — the finite set of alphanumeric character strings that begin with an
uppercase character; e.g. <code>X</code>, <code>A</code>, <code>Var</code>.</li>
</ul>
<p>While it would appear that the values from $\small \mathcal{C}$ and $\small \mathcal{P}$ would
intersect, these values must remain distinct. For example, the value <code>human</code> is a valid predicate and
string constant, but they have distinct types in ASDI that ensure they have distinct identities.</p>
<p>Each rule $\small r \in R$ has the form:</p>
<p>$$\tag{i}\small A_1, \ldots, A_m \leftarrow L_1, \ldots, L_n$$</p>
<p>as well as the following properties:</p>
<ul>
<li>$\small rule(x)$ a boolean predicate which returns <code>true</code> <strong>IFF</strong> $\small x$ is a rule.</li>
<li>$\small head(r)$ (the consequence), returns the set of <em>atom</em> values $\small A_1, \ldots, A_m$ where $\small m \in \mathbb{N}$,</li>
<li>$\small body(r)$ (the antecedence), returns the set of <em>literal</em> values $\small L_1, \ldots, L_n$ where $\small n \in \mathbb{N}$,</li>
<li>$\small distinguished(r)$ returns the set of <em>terms</em> in the head of a rule,
$$\tag{ii}\small distinguished(r) \coloneqq \lbrace t | t \in \bigcup\lbrace terms(a) | a \in head(r) \rbrace \rbrace$$</li>
<li>$\small non\text{-}distinguished(r)$ returns the set of <em>terms</em> in the body that of a rule that are not in the head,
$$\tag{iii}\small non\text{-}distinguished(r) \coloneqq \lbrace t | t \in ( \bigcup\lbrace terms(a) | a \in body(r) \rbrace - distinguished(r) \rbrace)\rbrace$$</li>
<li>$\small ground(r)$  a boolean predicate which returns <code>true</code> <strong>IFF</strong> its head and its body are both <em>ground</em>:
$$\tag{iv}\small ground(r) \coloneqq (\forall{a}\in head(r); ground(a)) \land (\forall{l}\in body(r); ground(l))$$</li>
<li>$\small positive(r)$ a boolean predicate which returns <code>true</code> <strong>IFF</strong> all body <em>literals</em> are <em>positive</em>:
$$\tag{v}\small positive(r) \coloneqq (\forall{l}\in body(r); positive(l))$$</li>
</ul>
<p>A <em>pure</em> rule is one where there is only a single atom in the head; if the body is true, the head is
true. A <strong>constraint</strong> rule, or contradiction, does not allow any consequence to be determined from
evaluation of its body. A <strong>disjunctive</strong> rule is one where there is more than one atom, and any one
may be true if the body is true. The language $\small\text{Datalog}^{\lor}$ allows for <em>inclusive</em>
disjunction, and while a language, $\small\text{Datalog}^{\oplus}$, exists for <em>exclusive</em> disjunction
it is not implemented here.</p>
<p>The property $\small form(r)$ returns the form of the rule, based
on the cardinality of the rule’s head as follows:</p>
<p>$$\tag{vi}\small
form(r) \coloneqq
\begin{cases}
pure, &amp;\text{if } |head(r)| = 1 \\
constraint, &amp;\text{if } |head(r)| = 0 \land \text{Datalog}^{\lnot} \\
disjunctive, &amp;\text{if } |head(r)| &gt; 1  \land \text{Datalog}^{\lor}
\end{cases}$$</p>
<p>Note that this notation is similar to that of a <a href="https://en.wikipedia.org/wiki/Sequent"><em>sequent</em></a>.
Taking our definition of a rule, $\small A_1, \ldots, A_m \leftarrow L_1, \ldots, L_n$, and swap the
order of antecedence and consequence we get $\small L_1, \ldots, L_m \vdash A_1, \ldots, A_n$.
A pure rule is termed a <em>simple conditional assertion</em>, a constraint rule is termed an
<em>unconditional assertion</em>, and a disjunctive rule is termed a <em>sequent</em> (or simply <em>conditional
assertion</em>).</p>
<p>Alternatively, some literature defines a rule in the following form:</p>
<p>$$\tag{ia}\small C_1 | C_2 | \ldots | C_n \leftarrow A_1, \ldots, A_m, \lnot B_1, \ldots, \lnot B_k$$</p>
<p>Where this form shows the expanded head structure according to $\small\text{Datalog}^{\lor}$, and the
set of negated literals according to $\small\text{Datalog}^{\lnot}$.</p>
<p>Datalog does not allow rules to infer new values for relations that exist in the extensional database. This may be
expressed as follows:</p>
<p>$$\tag{xvii}\small \mathcal{P}_E \cap \mathcal{P}_I = \empty$$</p>
<p>The same restriction is not required for constants in $\small \mathcal{C}_P$ or variables in
$\small \mathcal{V}_P$ which should be shared.</p>
<h2 id="terms"><a class="header" href="#terms">Terms</a></h2>
<p>Terms, mentioned above, may be constant values or variables such that
$\small\mathcal{T}=\mathcal{C}\cup\mathcal{V}\cup\bar{t}$ where $\small\bar{t}$ represents an
anonymous variable.</p>
<p>Terms have the following properties:</p>
<ul>
<li>$\small term(x)$ a boolean predicate which returns <code>true</code> <strong>IFF</strong> $\small x$ is a term.</li>
<li>$\small constant(t)$ a boolean predicate which returns <code>true</code> <strong>IFF</strong> the term argument is a constant value.</li>
<li>$\small variable(t)$ a boolean predicate which returns <code>true</code> <strong>IFF</strong> the term argument is a variable.</li>
<li>$\small anonymous(t)$ a boolean predicate which returns <code>true</code> <strong>IFF</strong> the term argument is the anonymous variable, $\small\bar{t}$.</li>
</ul>
<p>With the definition of rules so far it is possible to write rules that generate an an
infinite number of results. To avoid such problems Datalog rules are required to satisfy the
following <strong>Safety</strong> conditions:</p>
<ol>
<li>Every variable that appears in the head of a clause also appears in a positive relational literal
(atom) in the body of the clause.
$$\tag{vii}\small
\begin{alignat*}{2}
safe\text{-}head(r) &amp;\coloneqq &amp;&amp;\lbrace t | t \in distinguished(r), t \in \mathcal{V} \rbrace \\
&amp;- &amp;&amp;\lbrace t | t \in \bigcup\lbrace terms(a) | a \in body(r), atom(a), positive(a) \rbrace, t \in \mathcal{V} \rbrace \\
&amp;= &amp;&amp;\empty
\end{alignat*}$$</li>
<li>Every variable appearing in a negative literal in the body of a clause also appears in some
positive relational literal in the body of the clause.
$$\tag{viii}\small
\begin{alignat*}{2}
safe\text{-}negatives(r) &amp;\coloneqq &amp;&amp;\lbrace t | t \in \bigcup\lbrace terms(a) | a \in body(r), \lnot positive(a) \rbrace, t \in \mathcal{V} \rbrace \\
&amp;- &amp;&amp;\lbrace t | t \in \bigcup\lbrace terms(a) | a \in body(r), atom(a), positive(a) \rbrace, t \in \mathcal{V} \rbrace \\
&amp;= &amp;&amp;\empty
\end{alignat*}$$</li>
</ol>
<h2 id="atoms"><a class="header" href="#atoms">Atoms</a></h2>
<p>Atoms are comprised of a label, $\small p \in \mathcal{P}$, and a tuple of <em>terms</em>. A set of atoms
form a <strong>Relation</strong> if each <em>conforms to</em> the schema of the relation. The form of an
individual atom is as follows:</p>
<p>$$\tag{ix}\small p(t_1, \ldots, t_k)$$</p>
<p>as well as the following properties:</p>
<ul>
<li>$\small atom(x)$ a boolean predicate which returns <code>true</code> <strong>IFF</strong> $\small x$ is a atom.</li>
<li>$\small label(a)$ returns the predicate $\small p$,</li>
<li>$\small terms(a)$ returns the tuple of term values $\small t_1, \ldots, t_k$; where
$\small t \in \mathcal{T}$ and $\small k \in \mathbb{N}^{+}$,</li>
<li>$\small arity(a)$ returns the cardinality of the relation identified by the predicate;
$\small arity(a) \equiv |terms(a)| \equiv k$,</li>
<li>in $\small\text{Datalog}^{\Gamma}$:
<ul>
<li>there exists a type environment $\small \Gamma$ consisting of one or more types $\small \tau$,</li>
<li>each term $\small t_i$ has a corresponding type  $\small \tau_i$ where $\small \tau \in \Gamma$,</li>
<li>$\small type(t)$ returns the type $\small \tau$ for that term,</li>
<li>$\small types(a)$ returns a tuple such that;
$\small (i \in {1, \ldots, arity(a)} | type(t_i))$,</li>
</ul>
</li>
<li>$\small ground(a)$ a boolean predicate which returns <code>true</code> <strong>IFF</strong> its terms are all constants:
$$\tag{x}\small ground(a) \coloneqq (\forall{t}\in terms(a); t \in \mathcal{C})$$</li>
</ul>
<h2 id="relations"><a class="header" href="#relations">Relations</a></h2>
<p>Every relation $\small r$ has a schema that describes a set of attributes
$\small \lbrace \alpha_1, \ldots, \alpha_j \rbrace$, and each attribute may be labeled, and may in
$\small\text{Datalog}^{\Gamma}$ also have a type. In general, we refer to attributes by index, a value in
$\small 1, \cdots, j$.</p>
<p>Relations have the following properties:</p>
<ul>
<li>$\small relation(x)$ a boolean predicate which returns <code>true</code> <strong>IFF</strong> $\small x$ is a relation.</li>
<li>$\small label(r)$ returns the predicate $\small p$,</li>
<li>$\small schema(r)$ returns the set of attributes $\small \lbrace \alpha_1, \ldots, \alpha_j \rbrace$;
where $\small k \in \mathbb{N}^{+}$,</li>
<li>$\small arity(r)$ returns the number of attributes in the relation’s schema, and therefore all
atoms within the relation; $\small arity(r) \equiv |schema(a)| \equiv j$.</li>
<li>$\small atoms(r)$ returns the set of atoms that comprise this relation.</li>
</ul>
<blockquote>
<p>You will sometimes find the term <em>sort</em> used instead of <em>schema</em>. This term is used with meaning derived from 
<a href="https://en.wikipedia.org/wiki/Model_theory">Model Theory</a> (see also 
<span class="bibref inline"><a href="datalog/../reference/references.html#Wilfred22">Wilfred22</a></span>) as a partition of objects 
into similarly structured forms. Sort is used in this way extensively in 
<span class="bibref inline"><a href="datalog/../reference/references.html#AbHuVi94">AbHuVi94</a></span>.</p>
</blockquote>
<p>Attributes have the following properties:</p>
<ul>
<li>$\small index(\alpha)$ returns the index of this attribute in the schema, where $\small index \in \lbrace 1, \cdots, j \rbrace$.</li>
<li>$\small label(\alpha)$ returns either the predicate label of the attribute, or $\small\bot$.</li>
<li>in $\small\text{Datalog}^{\Gamma}$:
<ul>
<li>$\small type(\alpha)$ returns a type $\small \tau$ for the attribute, where $\small \tau \in \Gamma$, or $\small\bot$.</li>
</ul>
</li>
</ul>
<p>The following defines a binary function that determines whether an atom $\small a$ conforms to the
schema of a relationship $\small r$.</p>
<p>$$\tag{xi}\small
\begin{alignat*}{2}
conforms(a, r) &amp;\coloneqq &amp;&amp;ground(a) \\
&amp;\land &amp;&amp;label(a) = label(r) \\
&amp;\land &amp;&amp;arity(a) = arity(r) \\
&amp;\land &amp;&amp;\forall{i} \in [1, arity(r)] \medspace conforms( a_{t_i}, r_{\alpha_i} )
\end{alignat*}
$$
$$\tag{xii}\small
conforms(t, \alpha) \coloneqq
label(t) = label(\alpha) \land
\tau_{t} = \tau_{\alpha}
$$</p>
<p>Note that in relational algebra it is more common to use the term domain $\small D$ to denote a possibly
infinite set of values. Each attribute on a relation has a domain $\small D_i$ such that each ground
term is a value $\small d_i$ and the equivalent of $\small \tau_i \in \Gamma$ becomes
$\small d_i \in D_i$.</p>
<p>To visualize a set of facts in a relational form we take may create a table $p$, where each column,
or attribute, corresponds to a term index $1 \ldots k$. If the facts are typed then each column
takes on the corresponding $\tau$ type. Finally each row in the table is populated with the tuple
of term values.</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>$\small col_1: \tau_1$</th><th>$\small \ldots$</th><th>$\small col_k: \tau_k$</th></tr></thead><tbody>
<tr><td>$\small row_1$</td><td>$\small t_{1_1}$</td><td>$\small \ldots$</td><td>$\small t_{1_k}$</td></tr>
<tr><td>$\small \ldots$</td><td>$\small \ldots$</td><td>$\small \ldots$</td><td>$\small \ldots$</td></tr>
<tr><td>$\small row_y$</td><td>$\small t_{y_1}$</td><td>$\small \ldots$</td><td>$\small t_{y_k}$</td></tr>
</tbody></table>
</div>
<h2 id="literals"><a class="header" href="#literals">Literals</a></h2>
<p>Literals within the body of a rule, represent sub-goals that are the required to be true for the
rule’s head to be considered true.</p>
<ul>
<li>A literal may be an atom (termed a relational literal) or, in $\small\text{Datalog}^{\theta}$, a
conditional expression (termed an arithmetic literal),</li>
<li>an arithmetic literal has the form $\small \langle t_{lhs} \theta t_{rhs} \rangle$, where
<ul>
<li>$\small \theta \in \lbrace =, \neq, &lt;, \leq, &gt;, \geq \rbrace$,</li>
<li>in $\small\text{Datalog}^{\Gamma}$ both $\small t_{lhs}$ and $\small t_{rhs}$ terms have
corresponding types $\small \tau_{lhs}$ and $\small \tau_{rhs}$,</li>
<li>the types $\small \tau_{lhs}$ and $\small \tau_{rhs}$ <strong>must</strong> be <em>compatible</em>, for some
system-dependent definition of the property $\small compatible(\tau_{lhs}, \tau_{rhs}, \theta)$,</li>
</ul>
</li>
<li>in $\small\text{Datalog}^{\lnot}$ a literal may be negated, appearing as $\small \lnot l$,</li>
<li>and has the following properties:
<ul>
<li>$\small literal(x)$ a boolean predicate which returns <code>true</code> <strong>IFF</strong> $\small x$ is a literal.</li>
<li>$\small relational(l)$ a boolean predicate which returns <code>true</code> <strong>IFF</strong> the literal argument is a relational literal.</li>
<li>$\small arithmetic(l)$ a boolean predicate which returns <code>true</code> <strong>IFF</strong> the literal argument is a arithmetic literal.</li>
<li>$\small terms(l)$ returns the set of terms in a literal,
$$\tag{xiii}\small
terms(l) \coloneqq
\begin{cases}
terms(l), &amp;\text{if } relational(l) \\
\lbrace t_{lhs}, t_{rhs} \rbrace, &amp;\text{if } arithmetic(l) \land \text{Datalog}^{\theta}
\end{cases}$$</li>
<li>$\small ground(l)$ a boolean predicate which returns <code>true</code> <strong>IFF</strong> its terms are all constants $\small (\forall{t}\in terms(l); t \in \mathcal{C})$,</li>
<li>$\small positive(l)$ in $\small\text{Datalog}^{\lnot}$ returns <code>false</code> if negated,
otherwise it will always return <code>true</code>.</li>
</ul>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th></th><th>$\small relational(l)$</th><th>$\small arithmetic(l)$</th><th>$\small terms(l)$</th><th>$\small ground(l)$</th><th>$\small positive(l)$</th></tr></thead><tbody>
<tr><td>$\small p(X, Y)$</td><td><code>true</code></td><td><code>false</code></td><td>$\small \lbrace X, Y \rbrace$</td><td><code>false</code></td><td><code>true</code></td></tr>
<tr><td>$\small p(X, 1)$</td><td><code>true</code></td><td><code>false</code></td><td>$\small \lbrace X, 1 \rbrace$</td><td><code>false</code></td><td><code>true</code></td></tr>
<tr><td>$\small p(2, 1)$</td><td><code>true</code></td><td><code>false</code></td><td>$\small \lbrace 2, 1 \rbrace$</td><td><code>true</code></td><td><code>true</code></td></tr>
<tr><td>$\small X = 1$</td><td><code>false</code></td><td><code>true</code></td><td>$\small \lbrace X, 1 \rbrace$</td><td><code>false</code></td><td><code>true</code></td></tr>
<tr><td>$\small \lnot p(2, 1)$</td><td><code>true</code></td><td><code>false</code></td><td>$\small \lbrace 2, 1 \rbrace$</td><td><code>true</code></td><td><code>false</code></td></tr>
<tr><td>$\small \lnot X = 1$</td><td><code>false</code></td><td><code>true</code></td><td>$\small \lbrace X, 1 \rbrace$</td><td><code>false</code></td><td><code>false</code> †</td></tr>
</tbody></table>
</div>
<blockquote>
<p>† note that while $\small \lnot X = 1$ <strong>is</strong> a negative literal, the corresponding literal $\small X \neq 1$ <strong>is not</strong>.</p>
</blockquote>
<p>It is sometimes useful to consider the values <code>⊤</code> (tautology) and <code>⊥</code> (absurdity) as <em>pseudo-literals</em> given that certain 
expressions can be reduced to them. For example, the arithmetic literal $\small 1=1$ must always be <code>true</code> and can 
therefore be reduced to <code>⊤</code> (or discarded entirely); similarly the arithmetic literal $\small 1=2$ must always be 
<code>false</code> and can therefore be reduced to <code>⊥</code>. Any rule where any literal reduces to <code>⊥</code> can itself never be <code>true</code>. 
Any rule that only comprises literals that reduce to <code>⊤</code> must always be <code>true</code>.</p>
<h2 id="facts"><a class="header" href="#facts">Facts</a></h2>
<p>Any ground rule where $\small m=1$ and where $\small n=0$ is termed a <strong>Fact</strong> as it is true by
nature of having an empty body, or alternatively we may consider the body be comprised of the truth
value $\small\top$.</p>
<p>Facts have the following properties:</p>
<ul>
<li>$\small fact(x)$ a boolean predicate which returns <code>true</code> <strong>IFF</strong> $\small x$ is a fact. 
$$\tag{xiv}\small fact(r) \coloneqq (ground(r) \land form(r)=pure \land body(r)=\empty)$$</li>
</ul>
<h2 id="queries"><a class="header" href="#queries">Queries</a></h2>
<p>An atom may be also used as a <strong>Goal</strong> or <strong>Query</strong> clause in that its constant and variable terms
may be used to match facts from the known facts or those that may be inferred from the set of rules
introduced. A ground goal is simply determining that any fact exists that matches all the
constant values provided and will return true or false.
In the case that one or more variables exist a set of facts will be returned that match the
expressed constants and provide the corresponding values for the variables.</p>
<p>The set of relations accessible to queries in the program is the union of relations in the extensional and 
intensional databases.</p>
<p>$$\tag{xvi}\small \mathcal{P}_P = \mathcal{P}_E \cup \mathcal{P}_I$$</p>
<p>It should be noted that the same exists for constants and variables;
$\small \mathcal{C}_P = \mathcal{C}_E \cup \mathcal{C}_I$ and
$\small \mathcal{V}_P = \mathcal{V}_E \cup \mathcal{V}_I$.</p>
<p>Queries have the following properties:</p>
<ul>
<li>$\small query(x)$ a boolean predicate which returns <code>true</code> <strong>IFF</strong> $\small x$ is a query.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concrete-syntax"><a class="header" href="#concrete-syntax">Concrete Syntax</a></h1>
<p>The definitions below uses both Extended Backus-Naur Form (EBNF)<sup class="footnote-reference"><a href="#ebnf">1</a></sup> and 
syntax diagrams<sup class="footnote-reference"><a href="#railroad">2</a></sup> to focus on the concrete syntax as expressed in the 
text representation. The EBNF definition is somewhat simplified from the grammar used in the ASDI parser 
although any deviations do not significantly affect the meaning of the language.</p>
<h2 id="programs-1"><a class="header" href="#programs-1">Programs</a></h2>
<p>A program consists of a set of facts that comprise the extensional database, a list of rules that
comprise the intensional database, and possibly a set of queries to interrogate the result of any
reasoning performed over the program.</p>
<p><img src="datalog/images/program.png" alt="program" /></p>
<pre><code class="language-ebnf">program ::= pragma* ( fact | rule | query )* ;
</code></pre>
<p>A program consists of a single file containing facts, rules, and queries as well as any additional
files referenced via <em>pragmas</em>.</p>
<h2 id="facts-1"><a class="header" href="#facts-1">Facts</a></h2>
<p>Facts <strong>must</strong> be expressed in the form of ground atoms and so they have a specific rule rather
than a constrained form of the <code>atom</code> rule.</p>
<p><img src="datalog/images/fact.png" alt="fact" /></p>
<pre><code class="language-ebnf">fact    ::= predicate ( &quot;(&quot; constant ( &quot;,&quot; constant )* &quot;)&quot; )? &quot;.&quot; ;
</code></pre>
<p>A predicate is the identifier shared by a fact and relation.</p>
<p><img src="datalog/images/predicate.png" alt="predicate" /></p>
<pre><code class="language-ebnf">predicate
        ::= LC_ALPHA ( ALPHA | DIGIT | &quot;_&quot; )* ;
</code></pre>
<p><strong>Example</strong> – the following demonstrates a simple fact denoting that the constant <code>brooke</code> representing some
individual is the parent of some individual represented by the constant <code>&quot;Xerces&quot;</code>.</p>
<pre><code class="language-datalog">parent(&quot;Xerces&quot;, brooke).
</code></pre>
<h2 id="constant-values"><a class="header" href="#constant-values">Constant Values</a></h2>
<p>Constants are supported in three types, String, Numbers, and Boolean. Whereas some definitions of
Datalog introduce an additional Identifier type, ASDI treats these as <em>short strings</em> that can
safely be expressed without quotes; therefore, the values <code>xerces</code> and <code>&quot;xerces&quot;</code> are equivalent.</p>
<p><img src="datalog/images/constant.png" alt="constant" /></p>
<pre><code class="language-ebnf">constant
        ::= string | number | boolean ;
</code></pre>
<h3 id="strings"><a class="header" href="#strings">Strings</a></h3>
<p>Strings are described in both the identifier and quoted form in the <code>string</code> rule.</p>
<p><img src="datalog/images/string.png" alt="string" /></p>
<pre><code class="language-ebnf">string  ::= predicate ( &quot;:&quot; ALPHA ( ALPHA | DIGIT | &quot;_&quot; * )? )
            | DQUOTE [^\u{22}]* DQUOTE ;
</code></pre>
<h3 id="numbers"><a class="header" href="#numbers">Numbers</a></h3>
<p>Numeric values in ASDI take one of three forms, integers, decimal values, and floating point values.</p>
<blockquote>
<p>Currently, decimal types are not implemented.</p>
</blockquote>
<p><img src="datalog/images/number.png" alt="integer" /></p>
<pre><code class="language-ebnf">number  ::= float | decimal | integer
</code></pre>
<p>Integer values in ASDI are signed, 64-bit values (<code>i64</code>).</p>
<p><img src="datalog/images/integer.png" alt="integer" /></p>
<pre><code class="language-ebnf">integer ::= ( &quot;+&quot; | &quot;-&quot; )? DIGIT+
</code></pre>
<p>Decimal values in ASDI are … TBD.</p>
<p><img src="datalog/images/decimal.png" alt="integer" /></p>
<pre><code class="language-ebnf">decimal ::= integer &quot;.&quot; DIGIT+
</code></pre>
<p>Floating point values in ASDI are 65-bit IEEE floats (<code>f64</code>).</p>
<p><img src="datalog/images/float.png" alt="integer" /></p>
<pre><code class="language-ebnf">float   ::= decimal ( &quot;e&quot; | &quot;E&quot; ) integer
</code></pre>
<h3 id="booleans"><a class="header" href="#booleans">Booleans</a></h3>
<p>Boolean values may also be represented using <code>⊤</code> (down tack <code>\u{22a4}</code>) for true, and <code>⊥</code> (up tack
<code>\u{22a5}</code>) for false where this may improve readability.</p>
<p><img src="datalog/images/boolean.png" alt="boolean" /></p>
<pre><code class="language-ebnf">boolean ::= ( &quot;true&quot; | &quot;⊤&quot; ) | ( &quot;false&quot; | &quot;⊥&quot; ) ;
</code></pre>
<h3 id="rules-1"><a class="header" href="#rules-1">Rules</a></h3>
<p>As facts are syntactically distinct from rules in the text representation there is no need for empty
bodies – all rules <strong>must</strong> have at least one literal. Material implication may be written using
the Unicode character <code>⟵</code> (long leftwards arrow<code>\u{27f5}</code>).</p>
<p><img src="datalog/images/rule.png" alt="rule" /></p>
<pre><code class="language-ebnf">rule    ::= ( head | &quot;⊥&quot; )? ( &quot;:-&quot; | &quot;&lt;-&quot; | &quot;⟵&quot; ) body &quot;.&quot; ;
</code></pre>
<p>The head of a rule is a disjunction of atoms, or in the case of a constraint the head may is
optional or replaced by the value <code>&quot;⊥&quot;</code>.</p>
<p><img src="datalog/images/head.png" alt="head" /></p>
<pre><code class="language-ebnf">head    ::= ( atom ( ( &quot;;&quot; | &quot;|&quot; | &quot;OR&quot; | &quot;∨&quot; ) atom )* ) ;
</code></pre>
<p>The body of a rule is comprised of one, or more, literals.</p>
<p><img src="datalog/images/body.png" alt="body" /></p>
<pre><code class="language-ebnf">body    ::= literal ( ( &quot;,&quot; | &quot;&amp;&quot; | &quot;AND&quot; | &quot;∧&quot; ) literal )* ;
</code></pre>
<p><strong>Example</strong> – the following sets of rules are equivalent.</p>
<pre><code class="language-datalog">ancestor(X, Y) :- parent(X, Y).
ancestor(X, Y) &lt;- parent(X, Y).
ancestor(X, Y) ⟵ parent(X, Y).

movie_star(X) :- star(X)  ,  movie_cast_member(X, _, _).
movie_star(X) :- star(X)  &amp;  movie_cast_member(X, _, _).
movie_star(X) :- star(X) AND movie_cast_member(X, _, _).
movie_star(X) :- star(X)  ∧  movie_cast_member(X, _, _).
</code></pre>
<p><strong>Example</strong> – as described in the abstract syntax it is an error to use an extensional relation in the head of
a rule. The following will generate an error:</p>
<pre><code class="language-datalog">parent(&quot;Xerces&quot;, brooke).

parent(X,Y) :- father(X,Y).
</code></pre>
<p>The language feature <code>disjunction</code> corresponds to the language $\small\text{Datalog}^{\lor}$ and
allows multiple atoms to appear in the rule’s head with the semantics that these are choices. This
syntax will not be accepted unless the feature is enabled.</p>
<p><strong>Example</strong> – the following describes the rule that <em>if X is a parent then X is <strong>either</strong> a
father <strong>or</strong> mother</em>.</p>
<pre><code class="language-datalog">.feature(disjunction).

father(X) ;  mother(X) :- parent(X).
father(X) |  mother(X) :- parent(X).
father(X) OR mother(X) :- parent(X).
father(X) ⋁  mother(X) :- parent(X).
</code></pre>
<p>As the use of disjunction in this position in the head is <em>inclusive</em> it is considered that any rule as above can be transformed
into the following standard form. Clearly, in this case this is not the expected semantics which would require
an exclusive disjunction, the language $\small\text{Datalog}^{\oplus}$. Because the semantics may
cause such confusion ASDI does not do this transformation by default.</p>
<pre><code class="language-datalog">father(X) :- parent(X).
mother(X) :- parent(X).
</code></pre>
<p>The language feature <code>constraints</code> corresponds to the language $\small\text{Datalog}^{\Leftarrow}$ and
allows the specification of rules with no head. In this case the material implication symbol is
<strong>required</strong>, the falsum value is optional for readability, therefore the following rules are
equivalent.</p>
<pre><code class="language-datalog">.feature(constraints).

:- alive(X) AND dead(X).
⊥ ⟵ alive(X) ∧ dead(X).
</code></pre>
<h3 id="safety"><a class="header" href="#safety">Safety</a></h3>
<p>ASDI will disallow the addition of rules that are unsafe according to the abstract syntax. The
following are examples of unsafe rules:</p>
<ul>
<li><code>a(X) :- b(Y).</code> — because <code>X</code> appears as a distinguished variable but does not appear in a
positive relational literal, error
<a href="datalog/error/enum.Error.html#variant.NegativeVariablesNotAlsoPositive"><code>HeadVariablesMissingInBody</code></a>.</li>
<li><code>a(X) :- b(Y), NOT b(X).</code> — because <code>X</code> appears in a negated literal but does not appear in a
positive relational literal, error
<a href="datalog/error/enum.Error.html#variant.NegativeVariablesNotAlsoPositive"><code>NegativeVariablesNotAlsoPositive</code></a>.</li>
<li><code>a(X) :- b(Y), X &lt; Y.</code> — Because <code>X</code> appears in an arithmetic literal but does not appear in a
positive relational literal, error
<a href="datalog/error/enum.Error.html#variant.ArithmeticVariablesNotAlsoPositive"><code>ArithmeticVariablesNotAlsoPositive</code></a>.</li>
</ul>
<h2 id="atoms-1"><a class="header" href="#atoms-1">Atoms</a></h2>
<p>The text representation of an atom is a relatively simple translation from the abstract syntax
above.</p>
<p><img src="datalog/images/atom.png" alt="atom" /></p>
<pre><code class="language-ebnf">atom    ::= predicate &quot;(&quot; term ( &quot;,&quot; term )* &quot;)&quot; ;
</code></pre>
<p><img src="datalog/images/term.png" alt="term" /></p>
<pre><code class="language-ebnf">term    ::= variable | constant ;
</code></pre>
<p>Note that we explicitly separate variables into named and anonymous forms here.</p>
<p><img src="datalog/images/variable.png" alt="variable" /></p>
<pre><code class="language-ebnf">variable
        ::= named-variable | anon-variable ;
</code></pre>
<p><img src="datalog/images/named-variable.png" alt="named-variable" /></p>
<pre><code class="language-ebnf">named-variable
        ::= UC_ALPHA ( ALPHA | DIGIT | &quot;_&quot; )* ;
        
anon-variable
        ::= &quot;_&quot; ;
</code></pre>
<p><strong>Example</strong> – the following are all valid body atoms.</p>
<pre><code class="language-datalog">dead(julius_caesar).
emperor(julius_caesar, rome).
emperor(X, Y).
emperor(X, rome).
</code></pre>
<h2 id="literals-1"><a class="header" href="#literals-1">Literals</a></h2>
<p>Any valid atom is also a valid <em>positive relational</em> literal. The syntax below also allows for <em>negative</em>
literals as well as arithmetic expressions as literals. Conjunction may be written with the Unicode
character <code>∧</code> (logical and <code>\u{2227}</code>).</p>
<p><img src="datalog/images/literal.png" alt="literal" /></p>
<pre><code class="language-ebnf">literal ::= ( &quot;!&quot; | &quot;NOT&quot; | &quot;￢&quot; )? ( atom | comparison ) ;
</code></pre>
<p><strong>Example</strong> – the following rules are all equivalent.</p>
<pre><code class="language-datalog">ancestor(X, Y) ⟵ parent(X, Z)  ,  ancestor(Z, Y).
ancestor(X, Y) ⟵ parent(X, Z)  &amp;  ancestor(Z, Y).
ancestor(X, Y) ⟵ parent(X, Z)  ∧  ancestor(Z, Y).
ancestor(X, Y) ⟵ parent(X, Z) AND ancestor(Z, Y).
</code></pre>
<p>The language feature <code>negation</code> corresponds to the language $\small\text{Datalog}^{\lnot}$ and
allows the specification of negated literals. Negation may also be written using the Unicode
character <code>￢</code> (full-width not sign <code>\u{ffe2}</code>). The following rules are equivalent.</p>
<pre><code class="language-datalog">.feature(negation).

alive(X) :- person(X), NOT dead(X).
alive(X) ⟵ person(X) ∧ ￢dead(X).
</code></pre>
<p>The following will fail as the negated rule is not considered safe ([Error::NegativeVariablesNotAlsoPositive]).</p>
<pre><code class="language-datalog">.feature(negation).

alive(X) :- NOT dead(X).
alive(X) ⟵ ￢dead(X).
</code></pre>
<h2 id="arithmetic-literals"><a class="header" href="#arithmetic-literals">Arithmetic Literals</a></h2>
<p>The language feature <code>comparisons</code> corresponds to the language $\small\text{Datalog}^{\theta}$ and
allows the use of arithmetic literals. Comparisons take place between two literals and are
currently limited to a set of common operators. Note the addition of a string match operator, this
is similar to the Perl <code>=~</code> and requires a string value/variable on the left and a string value or
variable on the right that compiles to a valid Rust regular expression. Finally, the rule <code>named-term</code>
disallows the use of anonymous variables in arithmetic literals.</p>
<p><img src="datalog/images/comparison.png" alt="comparison" /></p>
<pre><code class="language-ebnf">comparison
        ::= ( named-variable | constant ) operator ( named-variable | constant ) ;
</code></pre>
<p><img src="datalog/images/operator.png" alt="operator" /></p>
<pre><code class="language-ebnf">operator
        ::= &quot;=&quot;
            | (&quot;!=&quot; | &quot;/=&quot; | &quot;≠&quot;)
            | &quot;&lt;&quot;
            | (&quot;&lt;=&quot; | &quot;≤&quot;)
            | &quot;&gt;&quot;
            | (&quot;&gt;=&quot; | &quot;≥&quot;)
            | (&quot;*=&quot; | &quot;≛&quot; | &quot;MATCHES&quot;) ;
</code></pre>
<p>The Unicode characters <code>≠</code> (not equal to <code>\u{2260}</code>), <code>≤</code> (less-than or equal to <code>\u{2264}</code>),
<code>≥</code> (greater-than or equal to <code>\u{2265}</code>, and star equals <code>\u{e2899b}</code>) may be substituted for the
common arithmetic and string operators.</p>
<p>All arithmetic operations <strong>must</strong> be between terms of the some type, such that the property
<em>compatible</em> introduce above is defined as:</p>
<p>$$\tag{xvi}\small compatible(\tau_{lhs}, \tau_{rhs}, \theta) \leftarrow \tau_{lhs} = \tau_{rhs}$$</p>
<p>Additionally, some operators are not present for all types, as shown in the table below.</p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th><code>=</code>, <code>≠</code></th><th><code>&lt;</code>, <code>≤</code>, <code>&gt;</code>, <code>≥</code></th><th><code>≛</code></th></tr></thead><tbody>
<tr><td>String</td><td>Yes</td><td>Yes - lexical</td><td>Yes</td></tr>
<tr><td>Integer</td><td>Yes</td><td>Yes</td><td>No</td></tr>
<tr><td>Boolean</td><td>Yes</td><td>No</td><td>No</td></tr>
</tbody></table>
</div>
<p><strong>Example</strong> – the following is an example using arithmetic literals and the <em>car</em> relation.</p>
<pre><code class="language-datalog">.feature(comparisons).
.assert car(make: string, model: string, age: integer).

antique(X, Y) :- car(X, Y, _) AND X *= &quot;[dD]uesenberg&quot;.
antique(X, Y) :- car(X, Y, _) AND Y = &quot;model t&quot;.
antique(X, Y) :- car(X, Y, Z) AND Z &gt; 50.
</code></pre>
<h2 id="queries-1"><a class="header" href="#queries-1">Queries</a></h2>
<p>A query is simply an atom, but one identified to the system as a goal with either the prefix <code>?-</code>
or the suffix <code>?</code>.</p>
<p><img src="datalog/images/query.png" alt="query" /></p>
<pre><code class="language-ebnf">query   ::= ( &quot;?-&quot; atom &quot;.&quot; ) | ( atom &quot;?&quot; ) ;
</code></pre>
<p><strong>Example</strong> – the following queries are equivalent and will return the value of the variable <code>X</code> for any facts in
the <em>ancestor</em> relationship where the first attribute is the string value <code>&quot;xerces&quot;</code>.</p>
<pre><code class="language-datalog">?- ancestor(xerces, X).
ancestor(xerces, X)?
</code></pre>
<p>When the value <code>_</code> is used in a query it denotes an attribute of the relation that has no meaning
in either the query or the response. For example, in the following query we ask for all values of
the <em>model</em> attribute in the <em>car</em> relation where the <em>make</em> is “ford”, and ignore the age entirely.</p>
<pre><code class="language-datalog">.assert car(make: string, model: string, age: integer).

car(&quot;ford&quot;, X, _)?
</code></pre>
<p>The results of this query would not include the age column:</p>
<pre><code class="language-text">+------------+
| model      |
+============+
| edge       |
+------------+
| escort     |
+------------+
| fiesta     |
+------------+
| focus      |
+------------+
| fusion     |
+------------+
| mustang    |
+------------+
     ...
</code></pre>
<h2 id="pragmas"><a class="header" href="#pragmas">Pragmas</a></h2>
<p>Pragmas are declarative statements meant for the parser and runtime tooling, they do not affect
the meaning of the program itself.</p>
<p><img src="datalog/images/pragma.png" alt="pragma" /></p>
<pre><code class="language-ebnf">pragma  ::= &quot;.&quot; ( feature | assert | infer | fd | input | output ) &quot;.&quot; ;
</code></pre>
<h3 id="pragma-feature"><a class="header" href="#pragma-feature">pragma feature</a></h3>
<p>The <code>feature</code> pragma determines which Datalog language is in use. Use of syntax not supported by the
selected language feature will result in errors.</p>
<p><img src="datalog/images/feature.png" alt="feature" /></p>
<pre><code class="language-ebnf">feature ::= &quot;feature&quot; &quot;(&quot; feature-id ( &quot;,&quot; feature-id )* &quot;)&quot; ;
</code></pre>
<p><img src="datalog/images/feature-id.png" alt="feature-id" /></p>
<pre><code class="language-ebnf">feature-id
        ::= &quot;comparisons&quot;
        | &quot;constraints&quot;
        | &quot;disjunction&quot;
        | &quot;negation&quot;
        | &quot;functional_dependencies&quot;
</code></pre>
<p><strong>Example</strong></p>
<pre><code class="language-datalog">.feature(negation).
.feature(comparisons, disjunction).
</code></pre>
<h3 id="pragma-assert"><a class="header" href="#pragma-assert">pragma assert</a></h3>
<p>The <code>assert</code> pragma describes a new relation in the extensional database. The parser can determine
the schema for facts from their types in the database. The use of this pragma is therefore optional,
but recommended.</p>
<p><img src="datalog/images/assert.png" alt="assert" /></p>
<pre><code class="language-ebnf">assert  ::= &quot;assert&quot; predicate &quot;(&quot; attribute-decl ( &quot;,&quot; attribute-decl )* &quot;)&quot; ;
</code></pre>
<p><img src="datalog/images/attribute-decl.png" alt="attribute-decl" /></p>
<pre><code class="language-ebnf">attribute-decl
        ::= ( predicate &quot;:&quot; )? ( &quot;boolean&quot; | &quot;integer&quot; | &quot;string&quot; ) ;
</code></pre>
<p><strong>Example</strong></p>
<pre><code class="language-datalog">.assert human(name: string).
</code></pre>
<h3 id="pragma-infer"><a class="header" href="#pragma-infer">pragma infer</a></h3>
<p>The <code>infer</code> pragma describes a new relation in the intensional database. Typically the parser
can determine the schema for relational literals from their context, The use of this pragma
is therefore optional, but recommended. The alternate form is more explicit in that it defines
an intensional relation in terms of a previously defined extensional relation.</p>
<p><img src="datalog/images/infer.png" alt="infer" /></p>
<pre><code class="language-ebnf">infer   ::= &quot;infer&quot;
            ( predicate &quot;(&quot; attribute-decl ( &quot;,&quot; attribute-decl )* &quot;)&quot; )
            | &quot;from&quot; predicate ;
</code></pre>
<p><strong>Example</strong></p>
<pre><code class="language-datalog">.infer mortal(name: string).
</code></pre>
<p>Alternatively the short-cut form is often more convenient.</p>
<pre><code class="language-datalog">.assert human(name: string).
.infer mortal from human.
</code></pre>
<h3 id="pragma-fd"><a class="header" href="#pragma-fd">pragma fd</a></h3>
<p>The <code>fd</code> pragma, short for <em>functional dependency</em>, introduces a relationship between one or more attributes on the
left-hand (determinant) side and one or more attributes on the right-hand (dependent) side. This relationship denotes
that for a relationship $\small R$ with attributes $\small a_1, \cdots, a_n$, every valid combination of determinant
values uniquely determines the value of the dependent values.</p>
<p>Note that this pragma is only valid if the corresponding language feature is enabled.</p>
<p><img src="datalog/images/fd.png" alt="input" /></p>
<pre><code class="language-ebnf">fd      ::= ( &quot;fd&quot; | &quot;functional_dependency&quot; ) 
            predicate &quot;:&quot;
            attribute-index-list ( &quot;--&gt;&quot; | &quot;⟶&quot; ) attribute-index-list
</code></pre>
<p><img src="datalog/images/attribute-index-list.png" alt="input" /></p>
<pre><code class="language-ebnf">attribute-index-list
        ::= attribute-index ( &quot;,&quot; attribute-index )*
</code></pre>
<p>An attribute index is <em>either</em> an attribute label, if one has been declared for the relation, or an integer $\small i \in [1,|schema(R)|]$.</p>
<p><img src="datalog/images/attribute-index.png" alt="input" /></p>
<pre><code class="language-ebnf">attribute-index
        ::= integer | predicate
</code></pre>
<p><strong>Constraints</strong> – given the notational form $\small R: \alpha \rightarrow \Beta$;</p>
<ol>
<li>the initial predicate <strong>must</strong> be the label of an extensional relation:
$$\small R \in D_I \land label(R)$$</li>
<li>the set of attribute identifiers comprising the set $\small \alpha$ <strong>must</strong> be in $\small R$: 
$$\small \forall a \in \alpha (a \in schema(R))$$</li>
<li>the set of attribute identifiers comprising the set $\small \Beta$ <strong>must</strong> be in $\small R$:
$$\small \forall a \in \Beta (a \in schema(R))$$</li>
<li>the same attribute identifier <strong>must not</strong> appear in both determinant and dependent:
$$\small \alpha \cap \Beta = \emptyset$$</li>
</ol>
<p><strong>Example</strong> – given the extensional relation <em>employee</em> the two functional dependencies in the 
following are equivalent. Note that the implementation will ignore such duplicate declarations.</p>
<pre><code class="language-datalog">.feature(functional_dependencies).
.assert employee(id:integer, name:string).

.fd employee: id --&gt; name.
.fd employee: 1 ⟶ 2.
</code></pre>
<h3 id="pragma-input"><a class="header" href="#pragma-input">pragma input</a></h3>
<p>The <code>input</code> pragma instructs the parser to load facts for the named extensional relation from an
external file. This pragma <strong>requires</strong> that the relation be previously defined via the <code>assert</code>
pragma.</p>
<p><img src="datalog/images/input.png" alt="input" /></p>
<pre><code class="language-ebnf">input   ::= &quot;input&quot; io-details &quot;.&quot;
</code></pre>
<p><img src="datalog/images/io-details.png" alt="io-details" /></p>
<pre><code class="language-ebnf">io-details
        ::= &quot;(&quot; predicate &quot;,&quot; quoted-string ( &quot;,&quot; quoted-string )? &quot;)&quot; ;
</code></pre>
<p><strong>Example</strong></p>
<pre><code class="language-datalog">.assert human(name: string).
.input(human, &quot;data/humans.csv&quot;, &quot;csv&quot;).
</code></pre>
<h3 id="pragma-output"><a class="header" href="#pragma-output">pragma output</a></h3>
<p>The <code>output</code> pragma instructs the parser to write facts from the named intensional relation to an
external file. This pragma <strong>requires</strong> that the relation be previously defined via the <code>infer</code>
pragma.</p>
<p><img src="datalog/images/output.png" alt="output" /></p>
<pre><code class="language-ebnf">output  ::= &quot;output&quot; io-details &quot;.&quot; ;
</code></pre>
<p><strong>Example</strong></p>
<pre><code class="language-datalog">.infer mortal(name: string).
.output(mortal, &quot;data/mortals.txt&quot;).
</code></pre>
<h2 id="comments"><a class="header" href="#comments">Comments</a></h2>
<p>Comments in Datalog are either 1) the <code>%</code> character and continue to the end of the line, or
2) C-style with <code>/*</code> to start and <code>*/</code> to end. These correspond to the same rules as Prolog.</p>
<p><img src="datalog/images/comment.png" alt="comment" /></p>
<pre><code class="language-ebnf">comment ::= &quot;%&quot; [^\r\n]* EOL
            | &quot;/&quot; &quot;*&quot; ( [^\*] | &quot;*&quot;+ [^\*\/] )* &quot;*&quot;+ &quot;/&quot; ;
</code></pre>
<p><strong>Example</strong></p>
<pre><code class="language-datalog">% Here's a comment
?- ancestor(xerces, X). % and another
?- ancestor(brooke /* and one inline */, X). % and another
</code></pre>
<h2 id="terminal-lexical-symbols"><a class="header" href="#terminal-lexical-symbols">Terminal (Lexical) Symbols</a></h2>
<p>The following are lexical rules that can be assumed by the rules above.</p>
<pre><code class="language-ebnf">EOL     ::= &quot;\n&quot; | &quot;\r\n&quot; | &quot;\r&quot; ;

WHITESPACE
        ::= &quot; &quot; | &quot;\t&quot; | EOL ;
        
DQUOTE
        ::= '&quot;' ;
        
LC_ALPHA
        ::= ? corresponds to the Unicode category 'Ll' (letter, lower case) ? ;
        
UC_ALPHA
        ::= ? corresponds to the Unicode category 'Lu' (letter, upper case) ? ;
        
ALPHA   ::= LC_ALPHA | UC_ALPHA ;

DIGIT   ::= ? corresponds to the Unicode category 'Nd' (decimal number) ? ;
</code></pre>
<hr />
<div class="footnote-definition" id="ebnf"><sup class="footnote-definition-label">1</sup>
<p>For the original description of the EBNF notation as it is used here, please refer to 
“<a href="http://www.w3.org/TR/2010/REC-xquery-20101214/#EBNFNotation">A.1.1 Notation</a>” in the 
<a href="http://www.w3.org/TR/2010/REC-xquery-20101214/">XQuery recommendation</a>. </p>
</div>
<div class="footnote-definition" id="railroad"><sup class="footnote-definition-label">2</sup>
<p>The syntax, or <em>railroad</em>, diagrams were generated by the <a href="https://www.bottlecaps.de/rr/ui">bottlecaps</a> online tool from the definition in the <a href="datalog/../reference/datalog_ebnf.html">appendix</a>.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="language-features"><a class="header" href="#language-features">Language Features</a></h1>
<p>By default, the language supported by ASDI is sometimes termed <em>Pure Datalog</em>. This language
allows for positive literals only, and allow for recursion. It does support additional features
with feature sets applied to programs. Without a feature specified certain types will fail
well-formedness rules, the parser will report errors, and some tools will not execute. However,
the enabling of features is relatively simple in both the text representation using the <code>.feature</code>
pragma, and using <code>FeatureSet</code>s in the API.</p>
<h2 id="negation"><a class="header" href="#negation">Negation</a></h2>
<p>The feature <code>negation</code> enables the negation of individual literals in the body of a rule. This
language is often described as $\text{\small{Datalog}}^{\lnot}$.</p>
<pre><code class="language-datalog">.features(negation).
alive(X) :- person(X) AND NOT dead(X).
alive(X) :- person(X) ∧ ￢dead(X).
</code></pre>
<p>The text representation allows for <code>&quot;!&quot;</code>, <code>&quot;￢&quot;</code>, and <code>&quot;NOT&quot;</code> to be used to denote negation.</p>
<h2 id="constraints"><a class="header" href="#constraints">Constraints</a></h2>
<p>The feature <code>constraints</code> enables the specification of rules that have no head, which in turn
specifies a rule that <em>may never</em> be true. This language is described herein as
$\text{\small{Datalog}}^{\bot}$.</p>
<pre><code class="language-datalog">.features(constraints).
⊥ :- dead(X) AND alive(X).
:- dead(X) AND alive(X).
</code></pre>
<p>The text allows for either an entirely missing head, or the value <code>&quot;⊥&quot;</code> as the head to denote
a constraint. The latter signifies that the rule implies falsity (or absurdity).</p>
<h2 id="comparisons"><a class="header" href="#comparisons">Comparisons</a></h2>
<p>The feature <code>comparisons</code> enables the inclusion of literal terms that use standard comparison
operators. This language is described herein as $\text{\small{Datalog}}^{\theta}$.</p>
<pre><code class="language-datalog">.features(comparisons).
old(X) :- age(X, Y) ∧ Y &gt; 75.
</code></pre>
<p>The text representation supports the operators equality (<code>&quot;=&quot;</code>), inequality (<code>&quot;!=&quot;</code>, <code>&quot;/=&quot;</code>,
or <code>&quot;≠&quot;</code>), less than (<code>&quot;&lt;&quot;</code>), less than or equal-to (<code>&quot;&lt;=&quot;</code>, or <code>&quot;≤&quot;</code>), greater than (<code>&quot;&gt;&quot;</code>), and
greater than or equal-to (<code>&quot;&gt;=&quot;</code>, or <code>&quot;≥&quot;</code>).</p>
<h2 id="disjunction"><a class="header" href="#disjunction">Disjunction</a></h2>
<p>The feature <code>disjunction</code> enables the negation of individual literals in the body of a rule. This
language is often described as $\text{\small{Datalog}}^{\lor}$.</p>
<pre><code class="language-datalog">.features(disjunction).
mother(X, Y) OR father(X, Y) :- parent(X, Y).
mother(X, Y) ∨ father(X, Y) :- parent(X, Y).
</code></pre>
<p>The text representation allows for <code>&quot;;&quot;</code>, “|”<code>, </code>“∨”<code>, and </code>“OR”` to be used to denote disjunction.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>The following demonstrates the text representation support for enabling features.</p>
<pre><code class="language-datalog">.features(negation, comparisons, disjunction).
</code></pre>
<p>Similarly, the following API example shows how to create a feature set that may be added to a
program during creation.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use asdi::features::{
    FEATURE_COMPARISONS, FEATURE_DISJUNCTION, FEATURE_NEGATION, FeatureSet
};

let features = FeatureSet::from(vec![FEATURE_NEGATION, FEATURE_DISJUNCTION]);

assert!(features.supports(&amp;FEATURE_NEGATION));
assert!(!features.supports(&amp;FEATURE_COMPARISONS));

assert_eq!(features.to_string(), &quot;.feature(negation, disjunction).&quot;);
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="model-api"><a class="header" href="#model-api">Model API</a></h1>
<p>This chapter will walk through various parts of the ASDI crate, not as an API reference, which is to be found in
the <a href="https://docs.rs/asdi/latest/asdi/">rust doc</a>, but at a higher level and so some specific details not be
covered here.</p>
<p>The following is a representation of the module structure, note that this isn’t quite the same as the book 
organization shown on the left.</p>
<p><img src="model/top.svg" alt="Module Structure" /></p>
<div class="figure caption">3.1: crate module structure.</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="programs-2"><a class="header" href="#programs-2">Programs</a></h1>
<p>A <code>Program</code> is the key entry point in the crate, and it is provided in the crate’s root. The following diagram shows 
the content of the root, with the program class in bold. As you can see the program class is an aggregate of other
classes in modules <code>edb</code>, <code>features</code>, <code>idb</code>, and <code>idb::query</code>.</p>
<p><img src="model/lib.svg" alt="Library Top Level" /></p>
<div class="figure caption">3.2: library top level</div>
<h2 id="traits"><a class="header" href="#traits">Traits</a></h2>
<p>The crate root also includes a number of common traits. In the following diagram the details of these traits are
shown, eliding a number of the classes from the figure above.</p>
<p><img src="model/lib_traits.svg" alt="Program" /></p>
<div class="figure caption">3.3: common traits, expanded</div>
<h2 id="program"><a class="header" href="#program">Program</a></h2>
<p>The following is an expanded view of the Program struct from figure 3.2. Note that, in this diagram, the fill color 
for some classes was set to white. This is to indicate that while they are still important they are of secondary 
importance to the current discussion.</p>
<p><img src="model/lib_program.svg" alt="Program" /></p>
<div class="figure caption">3.4: Program, expanded</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="program-features"><a class="header" href="#program-features">Program Features</a></h1>
<p><img src="model/features.svg" alt="features module" /></p>
<div class="figure caption">3.5: the features module</div>
<h2 id="feature-details"><a class="header" href="#feature-details">Feature Details</a></h2>
<p>The following table lists the labels and symbols for each <code>Feature</code> currently supported in ASDI.</p>
<div class="table-wrapper"><table><thead><tr><th>Language Feature</th><th>Label String</th><th>Symbol Char</th></tr></thead><tbody>
<tr><td><code>FEATURE_COMPARISONS</code></td><td>“comparisons”</td><td>‘θ’</td></tr>
<tr><td><code>FEATURE_CONSTRAINTS</code></td><td>“constraints”</td><td>‘⇐’</td></tr>
<tr><td><code>FEATURE_DISJUNCTION</code></td><td>“disjunction”</td><td>‘∨’</td></tr>
<tr><td><code>FEATURE_NEGATION</code></td><td>“negation”</td><td>‘￢’</td></tr>
<tr><td><code>FEATURE_FUNCTIONAL_DEPENDENCIES</code></td><td>“functional_dependencies”</td><td>‘⟶’</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="program-parser"><a class="header" href="#program-parser">Program Parser</a></h1>
<p><img src="model/parse.svg" alt="parse module" /></p>
<div class="figure caption">3.6: the parser module</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="program-visitor"><a class="header" href="#program-visitor">Program Visitor</a></h1>
<p><img src="model/visitor.svg" alt="visitor module" /></p>
<div class="figure caption">3.7: the visitor module</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="relations-1"><a class="header" href="#relations-1">Relations</a></h1>
<p><img src="model/edb.svg" alt="Extensional Relations" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="relation-inputoutput"><a class="header" href="#relation-inputoutput">Relation Input/Output</a></h1>
<p><img src="model/edb_io.svg" alt="io module" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rules-2"><a class="header" href="#rules-2">Rules</a></h1>
<p><img src="model/idb.svg" alt="idb module" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="evaluation"><a class="header" href="#evaluation">Evaluation</a></h1>
<p><img src="model/idb_eval.svg" alt="idb::eval module" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stratification"><a class="header" href="#stratification">Stratification</a></h1>
<p><img src="model/idb_eval_strata.svg" alt="strata module" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="queries-2"><a class="header" href="#queries-2">Queries</a></h1>
<p><img src="model/idb_query.svg" alt="idb::query module" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="relational-algebra"><a class="header" href="#relational-algebra">Relational Algebra</a></h1>
<p><img src="model/idb_query_relational.svg" alt="idb::query::relational module" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h1>
<p><img src="model/error.svg" alt="error module" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="model-extension"><a class="header" href="#model-extension">Model Extension</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="relationset-io"><a class="header" href="#relationset-io">RelationSet I/O</a></h1>
<h2 id="reading-resource-sets"><a class="header" href="#reading-resource-sets">Reading Resource Sets</a></h2>
<p><img src="extension/i_o_reader.svg" alt="I/O extension point" /></p>
<h2 id="writing-resource-sets"><a class="header" href="#writing-resource-sets">Writing Resource Sets</a></h2>
<p><img src="extension/i_o_writer.svg" alt="I/O extension point" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-an-evaluator"><a class="header" href="#writing-an-evaluator">Writing an Evaluator</a></h1>
<p><img src="extension/evaluator.svg" alt="Evaluator extension point" /></p>
<h3 id="using-the-precedencegraph"><a class="header" href="#using-the-precedencegraph">Using the PrecedenceGraph</a></h3>
<p><img src="extension/evaluator_precedence.svg" alt="PrecedenceGraph" /></p>
<h3 id="using-the-stratifiedprogram"><a class="header" href="#using-the-stratifiedprogram">Using the StratifiedProgram</a></h3>
<p><img src="extension/evaluator_stratified.svg" alt="StratifiedProgram" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-a-formatter"><a class="header" href="#writing-a-formatter">Writing a Formatter</a></h1>
<h2 id="using-the-visitor-api"><a class="header" href="#using-the-visitor-api">Using the Visitor API</a></h2>
<p><img src="extension/visitors.svg" alt="Visitor details" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing"><a class="header" href="#contributing">Contributing</a></h1>
<blockquote>
<p>The latest version of this document can be found on GitHub as 
<a href="https://github.com/johnstonskj/rust-asdi/CONTRIBUTING.md">CONTRIBUTING.md</a>.</p>
</blockquote>
<p>You can contribute to <a href="https://github.com/johnstonskj/rust-asdi">ASDI</a> in a number of ways,</p>
<ol>
<li>file <a href="https://github.com/johnstonskj/rust-asdi/issues/new?assignees=&amp;labels=bug&amp;template=bug_report.md&amp;title=">bugs</a> and
<a href="https://github.com/johnstonskj/rust-asdi/issues/new?assignees=&amp;labels=enhancement&amp;template=feature_request.md&amp;title=">enhancement requests</a></li>
<li>review the <a href="https://docs.rs/asdi">documentation</a> and the <a href="https://simonkjohnston.life/rust-asdi/">book</a> and let us
know if you find are issues there</li>
<li>Fix or Add something and send us a pull request.</li>
</ol>
<p>We love pull requests from everyone. By participating in this project, you
agree to abide by our <a href="https://github.com/johnstonskj/rust-asdi/CODE_OF_CONDUCT.md">code of conduct</a>, and
<a href="https://github.com/johnstonskj/rust-asdi/LICENSE">License</a>.</p>
<p>Fork, then clone the repo:</p>
<pre><code>git clone git@github.com:johnstonskj/rust-asdi.git
</code></pre>
<p>Ensure you have a good Rust install, usually managed by <a href="https://rustup.rs/">Rustup</a>.
You can ensure the latest tools with the following:</p>
<pre><code>rustup update
</code></pre>
<p>Make sure the tests pass:</p>
<pre><code>cargo test --package asdi --no-fail-fast --all-features -- --exact
</code></pre>
<p>Make your change. Add tests, and documentation, for your change. Ensure not only that tests pass, but the following all run successfully.</p>
<pre><code>cargo doc --all-features --no-deps
cargo fmt
cargo clippy
</code></pre>
<p>If you made changes to the book source, ensure the following runs successfully</p>
<pre><code>mdbook build
</code></pre>
<p>If you have made any changes to <code>Cargo.toml</code>, also check:</p>
<pre><code>cargo outdated
cargo audit
</code></pre>
<p>Push to your fork and <a href="https://github.com/johnstonskj/rust-asdi/compare/">submit a pull request</a>.</p>
<p>At this point you’re waiting on us. We like to at least comment on pull requests
within three business days (and, typically, one business day). We may suggest
some changes or improvements or alternatives.</p>
<p>Some things that will increase the chance that your pull request is accepted:</p>
<ul>
<li>Write tests.</li>
<li>Write API documentation.</li>
<li>Write a <a href="https://cbea.ms/git-commit/https://cbea.ms/git-commit/">good commit message</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-abstract-graphical-view"><a class="header" href="#appendix-abstract-graphical-view">Appendix: Abstract Graphical View</a></h1>
<p>The following graph is an alternative representation of the <a href="reference/../datalog/abstract.html">abstract syntax</a>. It represents 
<em>leaf values</em> (constants, variables, …) in rectangles and <em>composite values</em> as ellipses. Additionally, where a 
composite is defined as $\small A \oplus B$ a small filled diamond shape represents the exclusive or relationship.
Finally, some edges in the graph are labeled with “<code>*</code>”, “<code>+</code>”, and “<code>?</code>” which are the common cardinality notation used
in regular expressions and BNF notation. </p>
<p><img src="reference/abstract_graph.svg" alt="Graphical View" /></p>
<ol>
<li>The edge between <em>rule</em> and <em>head</em> has the label “<code>?/*</code>” as it has differing cardinality under $\small\text{Datalog}$, 
$\small\text{Datalog}^{\lor}$, and $\small\text{Datalog}^{\bot}$. </li>
<li>The edge between <em>literal</em> and <em>negated?</em> is labeled as “<code>?</code>” as it is necessary under $\small\text{Datalog}^{\lnot}$
but not under $\small\text{Datalog}$.</li>
<li>The edge from the choice between <em>literal</em> and <em>comparison</em> is labeled as “<code>?</code>” as it is necessary under
$\small\text{Datalog}^{\theta}$ but not under $\small\text{Datalog}$.</li>
<li>The two dashed lines represent the following constraints.
<ol>
<li>Between <em>relation</em> and <em>predicate</em> to represent the fact that the predicate for a relation may be derived from the
predicate of the <em>atoms</em> within it (or vice versa).</li>
<li>Between <em>head</em> and <em>body</em> to represent the fact that while both are optional for a <em>rule</em>, one or other must be 
present.</li>
</ol>
</li>
</ol>
<h2 id="graphviz-source"><a class="header" href="#graphviz-source">GraphViz Source</a></h2>
<p>The following is the source for the graph above.</p>
<pre><code class="language-dot">digraph G {
  rankdir=LR;
  pad=0.1;
  splines=true;

  negated [label=&quot;negated?&quot;; shape=box; width=0.1; height=0.1];
  boolean [shape=box; width=0.1; height=0.1];
  string [shape=box; width=0.1; height=0.1];
  integer [shape=box; width=0.1; height=0.1];
  variable [shape=box; width=0.1; height=0.1];
  anonymous [shape=box; width=0.1; height=0.1];
  predicate [shape=box; width=0.1; height=0.1;];

  program [root=true];

  program -&gt; edb;
  program -&gt; idb;
  edb -&gt; relation [label=&quot;*&quot;];
  idb -&gt; relation [label=&quot;*&quot;];
  idb -&gt; rule [label=&quot;*&quot;];
  rule -&gt; head [label=&quot;?/*&quot;];
  head -&gt; atom;
  rule -&gt; body [label=&quot;?&quot;];
  body -&gt; literal [label=&quot;+&quot;];

  head -&gt; body [arrowhead=none;style=dashed;label=&quot;|head|+|tail|&gt;=1&quot;];

  literal -&gt; xor3;
  literal -&gt; negated [label=&quot;?&quot;];
  xor3 -&gt; atom;
  xor3 -&gt; comparison [label=&quot;?&quot;];

  comparison -&gt; term [label=&quot;lhs&quot;];
  comparison -&gt; term [label=&quot;rhs&quot;];
  comparison -&gt; operator;

  relation -&gt; predicate [style=dashed];
  relation -&gt; atom [label=&quot;*&quot;];
  atom -&gt; term [label=&quot;+&quot;];
  atom -&gt; predicate;

  term -&gt; xor2;
  xor2 -&gt; constant;
  xor2 -&gt; variable;
  xor2 -&gt; anonymous;

  xor1 [shape=diamond,style=filled,label=&quot;&quot;,height=.1,width=.1];
  xor2 [shape=diamond,style=filled,label=&quot;&quot;,height=.1,width=.1];
  xor3 [shape=diamond,style=filled,label=&quot;&quot;,height=.1,width=.1];

  constant -&gt; xor1;
  xor1 -&gt; integer;
  xor1 -&gt; string;
  xor1 -&gt; boolean;
}
</code></pre>
<p>This file is accessible directly <a href="reference/abstract_graph.dot">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-datalog-ebnf"><a class="header" href="#appendix-datalog-ebnf">Appendix: Datalog EBNF</a></h1>
<p>The following is the EBNF definition of the Datalog native text representation. Note that this is simplified somewhat
from the actual parser specification ASDI uses although in practice the differences are irrelevant.</p>
<pre><code class="language-ebnf">program ::= pragma* ( fact | rule | query )* ;

/* ************************************************************************* */

fact    ::= predicate ( &quot;(&quot; constant ( &quot;,&quot; constant )* &quot;)&quot; )? &quot;.&quot; ;

predicate
        ::= LC_ALPHA ( ALPHA | DIGIT | &quot;_&quot; )* ;

/* ************************************************************************* */

constant
        ::= string | number | boolean ;

string  ::= predicate ( &quot;:&quot; ALPHA ( ALPHA | DIGIT | &quot;_&quot; * )? )
            | DQUOTE [^#x22]* DQUOTE ;

number  ::= float | decimal | integer ;

integer ::= ( &quot;+&quot; | &quot;-&quot; )? DIGIT+ ;

decimal ::= integer &quot;.&quot; DIGIT+ ;

float   ::= decimal ( &quot;e&quot; | &quot;E&quot; ) integer ;

boolean ::= ( &quot;true&quot; | &quot;⊤&quot; ) | ( &quot;false&quot; | &quot;⊥&quot; ) ;

/* ************************************************************************* */

rule    ::= ( head | &quot;⊥&quot; )? ( &quot;:-&quot; | &quot;&lt;-&quot; | &quot;⟵&quot; ) body &quot;.&quot; ;

head    ::= ( atom ( ( &quot;;&quot; | &quot;|&quot; | &quot;OR&quot; | &quot;∨&quot; ) atom )* ) ;

body    ::= literal ( ( &quot;,&quot; | &quot;&amp;&quot; | &quot;AND&quot; | &quot;∧&quot; ) literal )* ;


/* ************************************************************************* */

atom    ::= predicate &quot;(&quot; term ( &quot;,&quot; term )* &quot;)&quot; ;

term    ::= variable | constant ;

variable
        ::= named-variable | anon-variable ;

named-variable
        ::= UC_ALPHA ( ALPHA | DIGIT | &quot;_&quot; )* ;

anon-variable
        ::= &quot;_&quot; ;

/* ************************************************************************* */

literal ::= ( &quot;!&quot; | &quot;NOT&quot; | &quot;￢&quot; )? ( atom | comparison ) ;

/* ************************************************************************* */

comparison
        ::= operand operator operand ;

operand ::= ( named-variable | constant ) ;

operator
        ::= &quot;=&quot;
            | (&quot;!=&quot; | &quot;/=&quot; | &quot;≠&quot;)
            | &quot;&lt;&quot;
            | (&quot;&lt;=&quot; | &quot;≤&quot;)
            | &quot;&gt;&quot;
            | (&quot;&gt;=&quot; | &quot;≥&quot;)
            | (&quot;*=&quot; | &quot;≛&quot; | &quot;MATCHES&quot;) ;

/* ************************************************************************* */

query   ::= ( &quot;?-&quot; atom &quot;.&quot; ) | ( atom &quot;?&quot; ) ;

/* ************************************************************************* */

pragma  ::= &quot;.&quot; ( feature | assert | infer | fd | input | output ) &quot;.&quot; ;

feature ::= &quot;feature&quot; &quot;(&quot; feature-id ( &quot;,&quot; feature-id )* &quot;)&quot; ;

feature-id
        ::= &quot;comparisons&quot;
        | &quot;constraints&quot;
        | &quot;disjunction&quot;
        | &quot;negation&quot;
        | &quot;functional_dependencies&quot; ;

assert  ::= &quot;assert&quot; predicate &quot;(&quot; attribute-decl ( &quot;,&quot; attribute-decl )* &quot;)&quot; ;

attribute-decl
        ::= ( predicate &quot;:&quot; )? ( &quot;boolean&quot; | &quot;integer&quot; | &quot;string&quot; ) ;

infer   ::= &quot;infer&quot;
            ( predicate &quot;(&quot; attribute-decl ( &quot;,&quot; attribute-decl )* &quot;)&quot;
            | &quot;from&quot; predicate ) &quot;.&quot; ;

fd      ::= ( &quot;fd&quot; | &quot;functional_dependency&quot; )
            predicate &quot;:&quot;
            attribute-index-list ( &quot;--&gt;&quot; | &quot;⟶&quot; ) attribute-index-list ;

attribute-index-list
        ::= attribute-index ( &quot;,&quot; attribute-index )* ;

attribute-index
        ::= integer | predicate ;

input   ::= &quot;input&quot; io-details ;

io-details
        ::= &quot;(&quot; predicate &quot;,&quot; quoted-string ( &quot;,&quot; quoted-string )? &quot;)&quot; ;

output  ::= &quot;output&quot; io-details ;

/* ************************************************************************* */

comment ::= &quot;%&quot; [^\r\n]* EOL
            | '/*' ( [^*] | '*'+ [^*/] )* '*'* '*/' ;

/* ************************************************************************* */

EOL     ::= &quot;\n&quot; | &quot;\\r\\n&quot; | &quot;\r&quot; ;

WHITESPACE
        ::= &quot; &quot; | &quot;\t&quot; | EOL ;

DQUOTE  ::= #x22 ;

LC_ALPHA
        ::= ? corresponds to the Unicode category 'Ll' ? ;

UC_ALPHA
        ::= ? corresponds to the Unicode category 'Lu' ? ;

ALPHA   ::= LC_ALPHA | UC_ALPHA ;

DIGIT   ::= ? corresponds to the Unicode category 'Nd' (decimal number) ? ;
</code></pre>
<p>This file is accessible directly <a href="reference/datalog.ebnf">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="relational-algebra-mapping"><a class="header" href="#relational-algebra-mapping">Relational Algebra Mapping</a></h1>
<p>Every expression in the <em>basic</em> <a href="https://en.wikipedia.org/wiki/Relational_algebra">relational algebra</a> 
can be expressed as a $\small\text{Datalog}$
query. However, operations in the extended relational algebra (grouping, aggregation, and sorting)
have no corresponding capability in $\small\text{Datalog}$. Similarly, $\small\text{Datalog}$ can
express recursion, which the relational algebra cannot. The following describes the foundational
relational operations and their $\small\text{Datalog}$ equivalent.</p>
<p>The semantics of $\small\text{Datalog}$ relations are primarily set based we would expect common
set operations to work in $\small\text{Datalog}$ rules. Given the relations R, $\small r(a,b,c)$,
and S, $\small s(d,e,f)$, we can easily describe the common set operations.</p>
<h2 id="union-smallcup"><a class="header" href="#union-smallcup">Union ($\small\cup$)</a></h2>
<p>Union is a binary operator that is written as $\small R \cup S$, where
$\small R$ and $\small S$ are relations.</p>
<p>For set union and set difference, the two relations involved must be <strong>union-compatible</strong> -—
that is, the two relations must have the same set of attributes. A strict form of this rule does not
allow for same-named attributes whereas a looser form allows duplicate names IFF they have identical
types. Because set intersection is defined in terms of set union and set difference, the two
relations involved in set intersection must also be union-compatible.</p>
<p>Consider the expression $\small U \coloneqq R \cup S$, which can be expressed as follows:</p>
<pre><code class="language-datalog">u(X, Y, Z) :- r(X, Y, Z).
u(X, Y, Z) :- s(X, Y, Z).
</code></pre>
<h2 id="difference-smallsetminus"><a class="header" href="#difference-smallsetminus">Difference ($\small\setminus$)</a></h2>
<p>Difference is a binary operator that is written as $\small R \setminus S$,
where $\small R$ and $\small S$ are relations. This cannot be
implemented in $\small\text{Datalog}$ as it required negation.</p>
<p>Consider the expression $\small D \coloneqq R \setminus S$ which can be expressed in
$\small\text{Datalog}^{\lnot}$ as follows:</p>
<pre><code class="language-datalog">d(X,Y,Z) :- r(X,Y,Z) AND NOT s(X,Y,Z).
</code></pre>
<h2 id="intersection-smallcap"><a class="header" href="#intersection-smallcap">Intersection ($\small\cap$)</a></h2>
<p>Intersection is a binary operator that is written as $\small R \cap S$, where
$\small R$ and $\small S$ are relations.</p>
<p>Consider the expression $\small I \coloneqq R \cap S$, which can be expressed as follows:</p>
<pre><code class="language-datalog">i(X,Y,Z) :- r(X,Y,Z) AND s(X,Y,Z).
</code></pre>
<p>Intersection may be defined in terms of the difference operation, as below.</p>
<p>$$\small R \cap S \enspace\equiv\medspace R \setminus (R \setminus S)$$</p>
<h2 id="cartesian-product-smalltimes"><a class="header" href="#cartesian-product-smalltimes">Cartesian Product ($\small\times$)</a></h2>
<p>Cartesian Product is a binary operator that is written as $\small R \times S$,
where $\small R$ and $\small S$ are relations. In relational algebra it is required that the two
relations involved must have disjoint headers—that is, they must not have a common attribute name.</p>
<p>The following is a valid expression of $\small P \coloneqq R \times S$:</p>
<pre><code class="language-datalog">p(A, B, C, D, E, F) :- r(A, B, C) AND s(D, E, F).
</code></pre>
<h2 id="projection-smallpi"><a class="header" href="#projection-smallpi">Projection ($\small\Pi$)</a></h2>
<p>Projection is a unary operation written as
$\small\Pi_{a_{1},\ldots ,a_{n}}(R)$ where $a_{1},\ldots ,a_{n}$ is a set of attribute names. The
result of such projection is defined as the set that is obtained when all tuples in $R$ are
restricted to the set $\small\lbrace a_{1},\ldots ,a_{n}\rbrace$. In some literature the lower case
$\small\pi$ is used instead of $\small\Pi$.</p>
<p>For example, the projection $\small P \coloneqq \Pi_{X} (R)$, a projection of the first attribute in R only,
can be expressed in $\small\text{Datalog}$ as either of the following equivalent rules.</p>
<pre><code class="language-datalog">p(X) :- r(X, Y, Z).
p(X) :- r(X, _, _).
</code></pre>
<h2 id="generalized-selection-smallsigma"><a class="header" href="#generalized-selection-smallsigma">Generalized Selection ($\small\sigma$)</a></h2>
<p>As defined by Codd, selection is written as $\small \sigma_{a\theta b}(R)$ or
$\small \sigma_{a\theta v}(R)$ where:</p>
<ul>
<li>$\small a$ and $\small b$ are attribute names,</li>
<li>$\small\theta$ is a binary operation, where $\small\theta\in\lbrace =, \neq, &lt;, \leq, &gt;, \geq \rbrace$,
<ul>
<li>ASDI adds the non-standard <em>string match</em> operator $\small\overset{\star}{=}$ to the set $\small\theta$,</li>
</ul>
</li>
<li>$\small v$ is a constant value,</li>
<li>$\small R$ is a relation,</li>
</ul>
<p>The selection $\small\sigma_{a\theta b}(R)$ denotes all tuples in $\small R$ for which $\small\theta$
holds between the $\small a$ and the $\small b$ attribute.</p>
<p>The selection $\small\sigma_{a\theta v}(R)$ denotes all tuples in $\small R$ for which $\small\theta$
holds between the $\small a$ attribute and the value $\small v$.</p>
<p>Selection requires arithmetic literals and therefore the languages $\small\text{Datalog}^{\theta}$
and $\small\text{Datalog}^{\lnot}$ for negation.</p>
<p><strong>Generalized Selection</strong> is a unary operation written as $\small\sigma_{\varphi}(R)$ where
$\small\varphi$ is a propositional formula that consists of conditions as allowed in the normal selection
and the logical operators $\small\land$ (and), $\small\lor$ (or) and $\small\lnot$ (negation). This selection
selects all those tuples in $\small R$ for which $\small\varphi$ holds.</p>
<p>In $\small\text{Datalog}^{\theta}$ the selection $\small L \coloneqq \sigma_{X&gt;100 \land Y=‘something’} (R)$
can be expressed as follows, where both rules are equivalent.</p>
<pre><code class="language-datalog">l(X, Y, Z) :- r(X, Y, Z) AND X &gt; 100 AND Y = something.
l(X, Y, Z) :- r(X, something, Z) AND X &gt; 100.
</code></pre>
<h2 id="rename-smallrho"><a class="header" href="#rename-smallrho">Rename ($\small\rho$)</a></h2>
<p>Rename is a unary operation written as $\small\rho_{a/b}(R)$ where the result is identical to $\small R$
except that the $\small b$ attribute in all tuples is renamed to an $\small a$ attribute. This is
simply used to rename the attribute of a relation or the relation itself. There is also the
$\small\rho_{x(A_{1},\ldots, A_{n})}(R)$ notation, where $\small R$ is renamed to $\small x$ and the
attributes $\small\lbrace a_{1},\ldots, a_{n}\rbrace$ are renamed to $\small\lbrace A_{1}, \ldots, A_{n}\rbrace$.</p>
<p>TBD</p>
<h2 id="theta-join-smalljoin_theta"><a class="header" href="#theta-join-smalljoin_theta">Theta Join ($\small\Join_{\theta}$)</a></h2>
<p>Theta Join is a binary operator that is written as $\small{R \Join S} \atop {a \theta b}$ and
$\small{R \Join S} \atop {a \theta v}$ or alternatively as $\small R \Join_{a \theta b} S$ and
$\small R \Join_{a \theta v} S$, where $\small R$ and $\small S$ are relations,
and the expressions $\small a\theta b$ and $\small a\theta v$ should be interpreted in the same way
as for selection.</p>
<p>A <strong>generalized Theta Join</strong> can be described following the convention of generalized selection where
$\small\theta$ expands into a propositional formula in the same manner as $\small\varphi$. Unfortunately
there is no notational alignment where a generalized theta join might be signified as
$\small\Join_{\varphi}$</p>
<p>For example, the natural join $\small J \coloneqq R \Join_{S.X&gt;100} S$, a join conditional join on an attribute
in S can be expressed in $\small\text{Datalog}^{\theta}$ as follows.</p>
<pre><code class="language-datalog">j(X,Y,Z) :- r(X,Y,Z) AND s(Xs,Y,Z) AND Xs &gt; 100.
</code></pre>
<p>It is possible to dispense with the theta join in most cases as it can be expressed in terms of
the selection and cartesian product operators described above.</p>
<p>$$\small R \Join_{\theta} \enspace\equiv\enspace \sigma_{\theta}(R \times S)$$</p>
<p>An <strong>Equi-Join</strong> is a special case of the Theta Join where $\small\theta$ contains only equalities.</p>
<h2 id="natural-join-smalljoin"><a class="header" href="#natural-join-smalljoin">Natural Join ($\small\Join$)</a></h2>
<p>Natural Join is a binary operator that is written as $\small R \Join S$, where $\small R$ and
$\small S$ are relations. The result of the natural join is the set of all combinations of tuples
in $\small R$ and $\small S$ that are equal on their common attribute names. The natural join is
arguably one of the most important operators since it is the relational counterpart of the logical
AND operator.</p>
<p>For example, the natural join $\small J = R \Join S$, a join on the first two attributes of R and S,
can be expressed in $\small\text{Datalog}$ as follows. Note that the common attributes are defined
by the names of their variables, not the underlying names of the attribute schema.</p>
<pre><code class="language-datalog">j(X,Y,Z,Q) :- r(X,Y,Z) AND s(X,Y,Q).
</code></pre>
<p>A Natural Join is a special case of the Equi-Join where equality operations are performed on all
common attributes.</p>
<h2 id="complex-expressions"><a class="header" href="#complex-expressions">Complex Expressions</a></h2>
<p>More complex examples can the be made from combining relational operators. The relational
query $\small A \coloneqq \Pi_{X}(\sigma_{Y = 3} (R) )$ becomes</p>
<pre><code class="language-datalog">a(X) :- r(X, 3, _).
</code></pre>
<p>Similarly, the relational query $\small A \coloneqq \Pi_{X}(\sigma_{Y = 3} (R) \Join_{R.X=S.X}\sigma_{Y = 5} (S))$
becomes</p>
<pre><code class="language-datalog">a(X) :- r(X, 3, _) AND s(X, 5, _).
</code></pre>
<h2 id="recursion"><a class="header" href="#recursion">Recursion</a></h2>
<p>Although relational algebra seems powerful enough for most practical purposes, there are some
simple and natural operators on relations that cannot be expressed by relational algebra.
One of them is the transitive closure of a binary relation. Given a domain $\small D$, let binary
relation $\small R$, $\small \text{Datalog } r(x, y)$, be a subset of $\small D\times D$. The transitive closure $\small R^{+}$ of $R$ is the smallest
subset of $\small D\times D$ that contains $R$ and satisfies the following condition:</p>
<p>$$\small\forall x\forall y\forall z\left((x,y)\in R^{+}\land (y,z)\in R^{+}\Rightarrow (x,z)\in R^{+}\right)$$</p>
<p>In Datalog this form of recursion is naturally expressed, as follows.</p>
<pre><code class="language-datalog">r_plus(X, Z) :- r(X, Y), r_plus(Y, Z).
</code></pre>
<h2 id="acknowledgements"><a class="header" href="#acknowledgements">Acknowledgements</a></h2>
<p>Examples in this section are taken from <em>Introduction to Data Management CSE 344, Lecture 10:
Datalog</em><span class="bibref"><a href="reference/references.html#Balaz12">Balaz12</a></span>, and definitions for 
the relational algebra are taken from <em>Relational algebra</em><span 
class="bibref"><a href="reference/references.html#WikiRelalg">WikiRelalg</a></span>. The <em>Relational Algebra Query Converter</em><span class="bibref"><a href="reference/references.html#QConv">QConv</a></span> is a useful tool to take a SQL query 
and convert to relational algebra which can then be converted to Datalog using the examples above.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-relational-algebra-ebnf"><a class="header" href="#appendix-relational-algebra-ebnf">Appendix: Relational Algebra EBNF</a></h1>
<pre><code class="language-ebnf">program
        ::= assignment | expression ;

assignment
        ::= identifier ( &quot;≔&quot; | &quot;:=&quot; ) expression ;

expression
        ::=  relation-identifier
          |  union
          |  intersection
          |  difference
          |  cartesian-product
          |  selection
          |  projection
          |  rename
          |  join
          |  &quot;(&quot; expression &quot;)&quot; ;

/* ************************************************************************* */

union   ::= expression ( &quot;∪&quot; | &quot;union&quot; ) expression ;

intersection
        ::= expression ( &quot;∩&quot; | &quot;intersect&quot; ) expression ;

difference
        ::= expression ( &quot;∖&quot; | &quot;-&quot; | &quot;diff&quot; ) expression ;

cartesian-product
        ::= expression ( &quot;⨯&quot; | &quot;×&quot; | &quot;product&quot; ) expression ;

selection
        ::= expression
            ( &quot;σ&quot; | &quot;select&quot; )
            &quot;[&quot; criteria (&quot;,&quot; criteria )* &quot;]&quot;
            expression ;

criteria
        ::= ( attribute-identifier | literal )
            operation
            ( attribute-identifier | literal ) ;

operation
        ::= &quot;=&quot; | &quot;!=&quot; &quot;&lt;&quot; | &quot;&lt;=&quot; | &quot;&gt;&quot; | &quot;&gt;=&quot; ;

projection
        ::= expression
            ( &quot;Π&quot; | &quot;π&quot; | &quot;project&quot; )
            &quot;[&quot; attribute-identifier (&quot;,&quot; attribute-identifier )* &quot;]&quot;
            expression ;

rename  ::= expression
            ( &quot;ρ&quot; | &quot;rename&quot; )
            &quot;[&quot; rename-pair (&quot;,&quot; rename-pair )* &quot;]&quot;
            expression ;

rename-pair
        ::= attribute-identifier &quot;=&quot; attribute-identifier ;

join    ::= expression
            ( natural-join | theta-join )
            expression ;

natural-join
        ::= &quot;⨝&quot; | &quot;natural-join&quot; ;

theta-join
        ::= ( &quot;⨝&quot; | &quot;theta-join&quot; )
            &quot;[&quot; criteria  (&quot;,&quot; criteria )* &quot;]&quot; ;

/* ************************************************************************* */

relation-identifier
        ::= ALPHA ( ALPHANUM | &quot;_&quot; )* ;

attribute-identifier
        ::= relation-identifier
            ( &quot;.&quot; ( relation-identifier | integer ) ) ;

/* ************************************************************************* */

literal ::= integer | string | boolean ;

integer ::= DIGIT+ ;

string  ::= QMARK [^#x22]* QMARK ;

boolean ::= &quot;true&quot; | &quot;false&quot; ;

QMARK  ::= #x22 ;
</code></pre>
<p>This file is accessible directly <a href="reference/relational.ebnf">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-first-order-logic--horn-clauses"><a class="header" href="#appendix-first-order-logic--horn-clauses">Appendix: First-Order Logic &amp; Horn Clauses</a></h1>
<p>This section does not provide a primer on propositional logic, or first-order predicate logic. However, some background may be required and this section will briefly outline key terms, we refer the reader to <span class="bibref inline"><a href="reference/../reference/references.html#AbHuVi94">AbHuVi94</a>, chapter 2</span>.</p>
<h2 id="propositional-logic"><a class="header" href="#propositional-logic">Propositional logic</a></h2>
<p>For Propositional logic we define a language comprising the following:</p>
<ol>
<li>An infinite set of propositional <em>variables</em>, $\small \mathcal{V}$.</li>
<li>The <em>constant</em> values <code>true</code> and <code>false</code>.</li>
<li>Propositional formulae $\small\varphi$, comprising variables, constants, the unary connective negation ($\small\lnot$) and the following binary connectives;
disjunction ($\small\lor$), conjunction ($\small\land$), implication ($\small\rightarrow$), and equivalence ($\small\leftrightarrow$).</li>
</ol>
<p>A <em>literal</em> is a (sub-)formula comprising a single variable or constant that may be negated, i.e. $\small p$ or $\small \lnot p$.</p>
<p>A propositional formula $\small\varphi$ is in <em>conjunctive normal form</em> (CNF) if it has the form </p>
<p>$$\tag{i}\small\psi_1 \land \cdots \land \psi_n$$</p>
<p>where each formula $\small\psi$ is a disjunction of literals.</p>
<h2 id="first-order-predicate-logic"><a class="header" href="#first-order-predicate-logic">First-Order Predicate logic</a></h2>
<p>First-Order Predicate logic is a more general language than propositional logic allowing predicate symbols that range over n-ary relationships. A <em>first-order language</em> $\small L$ is differentiated by the set of predicate symbols, constant values, and functions it chooses to allow. </p>
<ol>
<li>An infinite set of <em>variables</em> $\small \mathcal{V}$.</li>
<li>A set of constant values, $\small \mathcal{C}$, usually including <code>true</code> and <code>false</code>.</li>
<li>A set of n-ary predicate symbols, $\small \mathcal{P}$.</li>
<li>A set of n-ary function symbols, $\small \mathcal{F}$.</li>
<li><em>Well-formed formulae</em> (WFF) comprising variables, constants, the unary connective negation ($\small\lnot$) and the following binary connectives;
disjunction ($\small\lor$), conjunction ($\small\land$), implication ($\small\rightarrow$), and equivalence ($\small\leftrightarrow$).</li>
<li>The univeral quantifier $\small\forall$ and the existential quantifier $\small\exists$.</li>
</ol>
<p>An <em>atom</em> corresponds to the a propositional variable and is either <code>true</code>, <code>false</code>, or $\small p(t_1, \cdots, t_n)$, where $\small p$ is a predicate symbol and $\small t_1, \cdots, t_n$ are terms.</p>
<p>A <em>term</em> is either a variable, constant value, or function symbol.</p>
<p>Additionally, the language may include equality so as to allow atoms of the form $\small t_1 = t_2$. Note that <span class="bibref inline"><a href="reference/../reference/references.html#AbHuVi94">AbHuVi94</a></span> uses $\small t_1 \approx t_2$.</p>
<h2 id="horn-clauses"><a class="header" href="#horn-clauses">Horn Clauses</a></h2>
<p>A Clause is simply a disjunctions of positive $\small a_1, \cdots, a_m$ and negative $\small b_1, \cdots, b_n$ literals and may be written in either of the following forms.</p>
<p>$$\tag{ii}\small a_1 \lor \cdots \lor a_m \lor \lnot b_1 \lor \cdots \lor \lnot b_n$$</p>
<p>$$\tag{iii}\small \forall x_1, \cdots, x_k (a_1 \lor \cdots \lor a_m \lor \lnot b_1 \lor \cdots \lor \lnot b_n)$$</p>
<p>Where the latter form introduces the set of variables used in the clause. This is often removed for clarity as the universal quantification is assumed for any variable present. This can also be written in <em>clausal form</em>, something that looks a lot like Datalog.</p>
<p>$$\tag{iv}\small a_1, \cdots, a_m \leftarrow b_1, \cdots, b_n$$</p>
<p>A <em>Horn Clause</em> is a formula consisting of a disjunction of literals of which <strong>at most one</strong> is positive.</p>
<p>$$\tag{vi}\small a \lor \lnot b_1 \lor \cdots \lor \lnot b_n$$</p>
<p>or, in clausal form,</p>
<p>$$\tag{vii}\small a_1 \leftarrow b_1, \cdots, b_n$$</p>
<p>The following table describes additional clause forms along with their equivalent Datalog form.</p>
<div class="table-wrapper"><table><thead><tr><th>Propositional</th><th>Form/Datalog</th><th>Clausal</th></tr></thead><tbody>
<tr><td>$\small a_1(x,y) \lor a_2(x,y) \lor \lnot b_1(x,z) \lor \lnot b_2(z,y)$</td><td>indefinite/disjunctive</td><td>$\small a_1(x,y), a_2(x,y) \leftarrow b_1(x,z), b_2(z,y)$</td></tr>
<tr><td>$\small a(x,y) \lor \lnot b_1(x,z) \lor \lnot b_2(z,y)$</td><td>definite/pure<sup class="footnote-reference"><a href="#1">1</a></sup></td><td>$\small a(x,y) \leftarrow b_1(x,z), b_2(z,y)$</td></tr>
<tr><td>$\small b(x,y)$</td><td>unit/fact<sup class="footnote-reference"><a href="#2">2</a></sup></td><td>$\small b(x,y) \leftarrow$</td></tr>
<tr><td>$\lnot b_1(x,z) \lor \lnot b_2(z,y)$</td><td>goal/constraint</td><td>$\small \leftarrow b_1(x,z), b_2(z,y)$</td></tr>
<tr><td>$\small false$ or $\small\bot$</td><td>empty</td><td>$\small \square$</td></tr>
</tbody></table>
</div>
<h2 id="mapping-from-datalog-to-first-order-logic"><a class="header" href="#mapping-from-datalog-to-first-order-logic">Mapping from Datalog to First-Order Logic</a></h2>
<p>The purpose of the descriptions above was to allow for the mapping of Datalog into a <em>first-order language</em>.</p>
<p>Given a Datalog program $\small P=( D_E, D_I, Q )$ we can construct a new first-order language $\small L=(\mathcal{C},\mathcal{P},\mathcal{F})$ in the following manner.</p>
<ol>
<li>$\mathcal{C}$ is comprised the set of all constant values in any EDB or IDB relation.
$$\small \lbrace c | c \in \bigcup \lbrace terms(atoms(r)) | r \in extensional(P) \cap intensional(P) \rbrace \rbrace$$</li>
<li>$\mathcal{P}$ is comprised the set of labels for all EDB and IDB relations.
$$\small \lbrace label(r) | r \in extensional(P) \cap intensional(P) \rbrace$$</li>
<li>In $\small\text{Datalog}$, which does not allow functions, $\mathcal{F}=\empty$. However, in $\small\text{Datalog}^{\theta}$ which allows certain operators in arithmetic literals $\mathcal{F}=\theta$.</li>
<li>For each rule $\small r \in rules(P)$:</li>
</ol>
<p><strong>TBD</strong></p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>In Datalog a pure rule must also follow the safety constraint that all variables that appear in the head <strong>must also</strong> appear in the body.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>In Datalog a fact <strong>must also</strong> be ground.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-references"><a class="header" href="#appendix-references">Appendix: References</a></h1>
<div class="biblio">
<ol>
<li><span class="bibkey" id="AbHuVi94">AbHuVi94</span>Abiteboul, S., Hull, R., &amp; Vianu, V. <em>Foundations of Databases: The Logical Level</em>. (Pearson, 1995). <a href="http://webdam.inria.fr/Alice/">webdam.inria.fr/Alice/</a>.</li>
<li><span class="bibkey" id="Balaz12">Balaz12</span>Balazinska, M. <em>CSE 344: Introduction to Data Management. Lecture 10: Datalog</em>. (University of Washington, 2012). Retrieved January 24, 2022, from <a href="https://courses.cs.washington.edu/courses/cse344/12au/lectures/lecture10-datalog.pdf">courses.cs.washington.edu</a>.</li>
<li><span class="bibkey" id="CeGoTa90">CeGoTa90</span>Ceri, S., Gottlob, G., &amp; Tanca, L. <em>Logic Programming and Databases</em>. (Springer Berlin Heidelberg, 1990). <a href="https://doi.org/10.1007/978-3-642-83952-8">DOI: 10.1007/978-3-642-83952-8</a>.</li>
<li><span class="bibkey" id="ChVa97">ChVa97</span>Chaudhuri, S., and Vardi, M. Y. (1997). On the Equivalence of Recursive and Nonrecursive Datalog Programs. <em>Journal of Computer and System Sciences</em>, <em>54</em>(1), 61–78. <a href="https://doi.org/10.1006/JCSS.1997.1452">DOI: 10.1006/JCSS.1997.1452</a>.</li>
<li><span class="bibkey" id="Colomb">Colomb98</span>Colomb, R. M. <em>Deductive Databases and their Applications</em>. (Taylor &amp; Francis, 1998).</li>
<li><span class="bibkey" id="GreMol15">GreMol15</span>Greco, S. &amp; Molinaro, C. <em>Datalog and Logic Databases</em>. (Morgan &amp; Claypool Publishers, 2015).</li>
<li><span class="bibkey" id="Mill1851">Mill1851</span>Mill, J. S. <em>A System of Logic, Ratiocinative and Inductive, Being a Connected View of the Principles of Evidence, and the Methods of Scientific Investigation</em>. (John W. Parker, 1851).</li>
<li><span class="bibkey" id="QConv">QConv</span>Grammatical Framework. (March 1, 2018). <em>Query-converter – SQL to Relational Algebra</em>. Retrieved January 24, 2022, from <a href="http://www.grammaticalframework.org/qconv/qconv-a.html">grammaticalframework.org</a>.</li>
<li><span class="bibkey" id="Shep88">Shep88</span>Shepherdson, John C. <em>Negation in Logic Programming</em> in Foundations of Deductive Databases and Logic Programming. (1988).</li>
<li><span class="bibkey" id="WikiDatalog">WikiDatalog</span>Datalog. (January 9, 2022). In <em>Wikipedia</em>. Retrieved January 24, 2022, from  <a href="https://en.wikipedia.org/w/index.php?title=Datalog&amp;oldid=1064721744">en.wikipedia.org/Datalog</a>. </li>
<li><span class="bibkey" id="WikiRelalg">WikiRelalg</span>Relational algebra. (December 1, 2021). In <em>Wikipedia</em>. Retrieved January 24, 2022, from <a href="https://en.wikipedia.org/w/index.php?title=Relational_algebra&amp;oldid=1058055410">en.wikipedia.org/Relational_algebra</a>. </li>
<li><span class="bibkey" id="Wilfrid97">Wilfrid97</span>Hodges, W. <em>A Shorter Model Theory</em>. 1997. Cambridge University Press, USA.</li>
<li><span class="bibkey" id="Wilfrid22">Wilfrid22</span>Hodges, W. <em>Model Theory</em>. in The Stanford Encyclopedia of Philosophy (ed. Zalta, E. N.) (2022). <a href="https://plato.stanford.edu/archives/spr2022/entries/model-theory/">plato.stanford.edu/archives/spr2022/entries/model-theory/</a></li>
</ol>
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="datalog.js"></script>
        <script type="text/javascript" src="dot.js"></script>
        <script type="text/javascript" src="asdi.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
