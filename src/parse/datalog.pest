// ------------------------------------------------------------------------------------------------
// Top-Level definitions
// ------------------------------------------------------------------------------------------------

program = {
    SOI ~ pragma* ~ ( fact | rule | query )* ~ EOI
}

// ------------------------------------------------------------------------------------------------
// Intermediate definitions
// ------------------------------------------------------------------------------------------------

fact = {
    predicate ~ (LEFT_PAREN ~ constant_list ~ RIGHT_PAREN)? ~ DOT
}

rule = {
    rule_head? ~ material_implication ~ rule_body ~ DOT
}

rule_head = {
    // FEATURE: constraints
    UC_FALSUM
             // FEATURE: disjunction
    | atom ~ ( disjunction ~ atom )*
}

rule_body = {
    literal_list
}


query = {
    ( query_prefix ~ atom ~ DOT )
    | ( atom ~ QMARK )
}

atom = {
    predicate ~ ( LEFT_PAREN ~ term_list ~ RIGHT_PAREN )
}

literal = {
    // FEATURE: negation
    // FEATURE: comparisons
    negation? ~ ( atom | comparison )
}

literal_list = _{
    literal ~ ( conjunction ~ literal )*
}

comparison = {
    term ~ comparison_operator ~ term ?
}

term = {
    variable | constant
}

term_list = _{
    term ~ ( COMMA ~ term )*
}

constant = {
    identifier | string | number | boolean
}

constant_list = _{
    constant ~ ( COMMA ~ constant)*
}

predicate = @{
    LOWERCASE_LETTER ~ ( CASED_LETTER | DECIMAL_NUMBER | UNDERSCORE )*
}

variable = @{
    UNDERSCORE | ( UPPERCASE_LETTER ~ ( CASED_LETTER | DECIMAL_NUMBER | UNDERSCORE )* )
}

identifier = @{
    predicate ~ ( COLON ~ identifier_relaxed )?
}

identifier_relaxed = @{
    LETTER ~ ( CASED_LETTER | DECIMAL_NUMBER | UNDERSCORE )*
}

// ------------------------------------------------------------------------------------------------
// Pragmas
// ------------------------------------------------------------------------------------------------

pragma = {
    AT_SIGN ~ (pragma_assert | pragma_infer | pragma_feature | pragma_input | pragma_output) ~ DOT
}

pragma_assert = {
    keyword_assert ~ predicate ~ attribute_declaration_list
}

pragma_infer = {
    keyword_infer ~ predicate ~ ( attribute_declaration_list | ( "from" ~ predicate ))
}

attribute_declaration_list = _{
    LEFT_PAREN ~ attribute_declaration ~ (COMMA ~ attribute_declaration)* ~ RIGHT_PAREN
}

attribute_declaration = {
    ( predicate ~ ":" )? ~ ( type_id_string | type_id_integer | type_id_boolean )
}

pragma_feature = {
    keyword_feature ~ LEFT_PAREN ~ feature_list ~ RIGHT_PAREN
}

feature_list = _{
    feature_id ~ ( COMMA ~ feature_id )*
}

feature_id = _{
    feature_id_negation | feature_id_comparisons | feature_id_constraints | feature_id_disjunction
}

pragma_input = {
    keyword_input ~ LEFT_PAREN ~ predicate ~ COMMA ~ string ~ ( COMMA ~ string )? ~ RIGHT_PAREN
}

pragma_output = {
    keyword_output ~ LEFT_PAREN ~ predicate ~ COMMA ~ string ~ ( COMMA ~ string )? ~ RIGHT_PAREN
}

keyword_assert = _{
    "assert"
}

keyword_infer = _{
    "infer"
}

keyword_feature = _{
    "feature"
}

keyword_include = _{
    "include"
}

keyword_input = _{
    "input"
}

keyword_output = _{
    "output"
}

type_id_string = {
    "string"
}

type_id_integer = {
    "integer"
}

type_id_boolean = {
    "boolean"
}

feature_id_negation = {
    "negation"
}

feature_id_comparisons = {
    "comparisons"
}

feature_id_constraints = {
    "constraints"
}

feature_id_disjunction = {
    "disjunction"
}

// ------------------------------------------------------------------------------------------------
// Constant definitions
// ------------------------------------------------------------------------------------------------

string = ${
    QUOTE ~ string_inner ~ QUOTE
}

string_inner = @{
    string_char*
}

string_char = {
    !( "\"" | "\\" ) ~ ANY
    | "\\" ~ ( "\"" | "\\" | "t" )
    | "\\" ~ ( "u" ~ LEFT_BRACE ~ ASCII_HEX_DIGIT{2,6} ~ RIGHT_BRACE )
}

number = @{
    ( "+" | "-" )? ~ ASCII_DIGIT+ ~ ( DOT ~ ASCII_DIGIT+ )?
}

boolean = @{
    AT_SIGN ~ ( "true" | "false" )
}



// ------------------------------------------------------------------------------------------------
// Terminal definitions
// ------------------------------------------------------------------------------------------------

material_implication = _{
    ":-" | "<-" | UC_LEFT_ARROW_FW
}

negation = {
    EXCLAMATION | UC_LOGICAL_NOT_FW | "NOT"
}

conjunction = _{
    COMMA | UC_LOGICAL_AND | AMPERSAND | "AND"
}

disjunction = _{
    inclusive_disjunction
}

inclusive_disjunction = _{
    SEMI_COLON | UC_LOGICAL_OR | VERTICAL_BAR | "OR"
}

// ----- For future use -----
// exclusive_disjunction = _{
//     UC_LOGICAL_XOR | "XOR"
// }

query_prefix = _{
    "?-"
}

comparison_operator = {
    LESS_THAN | less_or_equal | GREATER_THAN | greater_or_equal | EQUALS | not_equal
}

less_or_equal = _{
    "<=" | UC_LTE
}

greater_or_equal = _{
    ">=" | UC_GTE
}

not_equal = _{
    "!=" | "/=" | UC_NOT_EQUAL
}

UC_LOGICAL_AND = _{ "∧" }

UC_LOGICAL_OR = _{ "∨" }

UC_LOGICAL_XOR = _{ "⊕" }

UC_LOGICAL_NOT_FW = _{ "￢" }

UC_LEFT_ARROW_FW = _{ "⟵" }

UC_TRUTH = _{ "⊤" }

UC_FALSUM = _{ "⊥" }

UC_LTE = _{ "≤" }

UC_GTE = _{ "≥" }

UC_NOT_EQUAL = _{ "≠" }

LEFT_PAREN = _{ "(" }

RIGHT_PAREN = _{ ")" }

LEFT_BRACE = _{ "{" }

RIGHT_BRACE = _{ "}" }

LESS_THAN = _{
    "<"
}

GREATER_THAN = _{ ">" }

EQUALS = _{ "=" }

QUOTE = _{ "\"" }

HYPHEN_MINUS = _{ "-" }

UNDERSCORE = _{ "_" }

AMPERSAND = _{ "&" }

VERTICAL_BAR = _{ "|" }

EXCLAMATION = _{ "!" }

DOT = _{ "." }

COMMA = _{ "," }

QMARK = _{ "?" }

AT_SIGN = _{ "@" }

COLON = _{ ":" }

SEMI_COLON = _{ ";" }

// ------------------------------------------------------------------------------------------------
// Built-in rules
// ------------------------------------------------------------------------------------------------

COMMENT = _{ "#" ~ ( !NEWLINE ~ ANY )* }

WHITESPACE = _{ " " | "\t" | NEWLINE }